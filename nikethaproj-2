#!/usr/bin/env python3
# I made some progress on the script this weekend. 
# So far it will loop through a list of languages and then loop through all 
# screens/variations defined in an input file 
# (this will be the one created by you parsing the code). 
# It will then search the "zStringsVsScreens.txt" file and capture all of the strings 
# that are on the corresponding screen/var. 

# So you will still need to strip those strings out of the variable that is holding them, 
# and then use that to parse the language.xml file. 
# I can probably help with that part too if I have some time later this week. 
# Let me know if you want to walk through it at all

import subprocess
import sys
import os
import csv
import re
from typing import Optional, List
import xml.etree.ElementTree as ET

Languages_To_Test = (
        ('Croation', 'LT'),
        ('Czech', 'LT'),
        ('Danish', 'LT'),
        ('English', 'LT')
    )

def run_executable(exe_path, arg1, arg2, arg3):
    """
    Run an executable file with three arguments.
    (Kept from your original script. Step 2 does not depend on this.)
    """
    if not os.path.exists(exe_path):
        print(f"Error: Executable not found at {exe_path}")
        return None
    
    if not os.access(exe_path, os.X_OK):
        print(f"Warning: {exe_path} may not be executable")
    
    try:
        result = subprocess.run(
            [exe_path, arg1, arg2, arg3],
            capture_output=True,
            text=True,
            timeout=60,
            check=False
        )
        print(f"Command executed: {exe_path} {arg1} {arg2} {arg3}")
        print(f"Exit code: {result.returncode}")
        if result.stdout:
            print("Output:")
            print(result.stdout)
        if result.stderr:
            print("Errors:")
            print(result.stderr)
        return result
    except FileNotFoundError:
        print(f"Error: Could not find executable: {exe_path}")
        return None
    except Exception as e:
        print(f"Error running executable: {e}")
        return None

def GetListofScreensAndVariations():
    screens = []
    with open('StringsAndVariations.csv', newline='') as f:
        reader = csv.reader(f)
        next(reader)  # skip header
        for row in reader:
            try:
                screens.append(row)
            except:
                print("Failed to Read Row in .csv")
    return screens

# ------------------------------
# STEP 1: Return SIDs only
# ------------------------------
SID_PATTERNS = [
    re.compile(r'\bSID\s*[:=]\s*(\d+)\b', re.IGNORECASE),  # "SID=12345" / "SID: 12345"
    re.compile(r'^\s*(\d+)\b'),                            # "12345 ..."
    re.compile(r'\[(\d+)\]'),                              # "[12345]"
]

def extract_sid(line: str):
    """Return the numeric SID as a string if found in the line; otherwise None."""
    for pat in SID_PATTERNS:
        m = pat.search(line)
        if m:
            return m.group(1)
    # Fallback: first 4+ digit chunk
    m = re.search(r'\b(\d{4,})\b', line)
    return m.group(1) if m else None

def GetStringsForScreen_Var(screen, var):
    """
    Reads zStringsVsScreens.txt, finds the block for the given screen/variation,
    and returns a clean list of SIDs (strings of digits), e.g. ['12345','67890'].
    """
    foundVar = False
    sids = []

    header_prefix = "Screen = " + str(screen) + ","
    header_suffix = " Variation = " + str(var) + " uses the following SIDs:"

    with open('zStringsVsScreens.txt', 'r', encoding='utf-8') as file:
        for line in file:
            if not foundVar and (header_prefix + header_suffix) in line:
                foundVar = True
                continue

            if foundVar and line.strip() == '':
                break

            if foundVar:
                sid = extract_sid(line)
                if sid:
                    sids.append(sid)

    return sids
# ------------------------------

# ------------------------------
# STEP 2: Load language XML (SpreadsheetML) → { SID: text } and map SIDs to texts
# ------------------------------

def parse_language_name(language_arg: str) -> str:
    """
    language_arg is like '-file=English' -> returns 'English'
    """
    try:
        return language_arg.split('=', 1)[1]
    except Exception:
        return language_arg

def get_language_xml_path(language_name: str) -> Optional[str]:
    """
    Look for XML files inside the 'strings' folder (per your project).
    """
    base_dir = os.path.join(os.getcwd(), "strings")  # assumes script runs from project root
    candidates = [
        os.path.join(base_dir, f"{language_name}.xml"),
        os.path.join(base_dir, f"{language_name}.XML"),
        os.path.join(base_dir, f"{language_name}_old.xml"),
        os.path.join(base_dir, f"{language_name}_old.XML"),
    ]
    for p in candidates:
        if os.path.exists(p):
            return p
    print(f"Warning: Could not find XML for language '{language_name}'. Tried: {candidates}")
    return None

# === SpreadsheetML helpers ===

SS_NS = "urn:schemas-microsoft-com:office:spreadsheet"
SS = f"{{{SS_NS}}}"  # namespace wrapper for ElementTree tag names

def _text(elem: Optional[ET.Element]) -> str:
    return (elem.text or "").strip() if elem is not None else ""

def _row_to_cells(row: ET.Element) -> List[str]:
    """
    Convert a SpreadsheetML Row into a list of cell values (handling ss:Index gaps).
    Returns a list of strings, each the Data text of the cell (or "" if blank).
    """
    cells: List[str] = []
    col_idx = 0
    for cell in row.findall(f".//{SS}Cell"):
        # Handle ss:Index (1-based)
        idx_attr = cell.get(f"{SS}Index")
        if idx_attr and idx_attr.isdigit():
            idx = int(idx_attr) - 1
            while col_idx < idx:
                cells.append("")
                col_idx += 1
        data = cell.find(f".//{SS}Data")
        cells.append(_text(data))
        col_idx += 1
    return cells

def _read_spreadsheetml_rows(xml_path: str) -> List[List[str]]:
    """
    Read all rows (as list of strings) from the first Worksheet/Table.
    """
    tree = ET.parse(xml_path)
    root = tree.getroot()
    # Find the first Worksheet/Table
    ws = root.find(f".//{SS}Worksheet")
    if ws is None:
        return []
    table = ws.find(f".//{SS}Table")
    if table is None:
        return []
    rows: List[List[str]] = []
    for row in table.findall(f".//{SS}Row"):
        rows.append(_row_to_cells(row))
    return rows

def load_language_map(xml_path: Optional[str], language_name: str = "English") -> dict:
    """
    Parse SpreadsheetML (Excel 2003 XML) and build { SID: localized_text } using
    the header row to locate the 'SID' column and the '<language_name>' column.
    """
    sid_to_text = {}
    if not xml_path:
        return sid_to_text

    try:
        rows = _read_spreadsheetml_rows(xml_path)
        if not rows:
            print(f"Error: No rows found in SpreadsheetML '{xml_path}'.")
            return {}

        # Find header row: look for a row containing 'SID' and the language name.
        header_idx = -1
        sid_col = -1
        lang_col = -1

        # Normalize header candidate cells by stripping spaces
        for i, row in enumerate(rows):
            lowered = [c.strip() for c in row]
            # Typical headers might be: ["ID", "Date", "SID", "English", ...]
            if "sid" in (x.lower() for x in lowered) and language_name.lower() in (x.lower() for x in lowered):
                header_idx = i
                # Decide exact columns
                for j, val in enumerate(lowered):
                    if val.lower() == "sid":
                        sid_col = j
                    if val.lower() == language_name.lower():
                        lang_col = j
                break

        if header_idx < 0 or sid_col < 0 or lang_col < 0:
            print(f"Error: Could not locate header with SID and '{language_name}' in '{xml_path}'.")
            return {}

        # Process subsequent rows
        for r in rows[header_idx+1:]:
            # Guard for short rows
            if sid_col >= len(r) or lang_col >= len(r):
                continue
            sid = r[sid_col].strip()
            txt = r[lang_col].strip()
            if sid.isdigit() and txt:
                sid_to_text[sid] = txt

        print(f"Loaded {len(sid_to_text)} strings from '{xml_path}'.")
        return sid_to_text

    except ET.ParseError as e:
        print(f"Error: Failed to parse XML '{xml_path}': {e}")
        return {}
    except Exception as e:
        print(f"Error: Unexpected while reading SpreadsheetML '{xml_path}': {e}")
        return {}

# ------------------------------

def LoopThroughScreens(executable_path, language, font):
    listOfScreens = GetListofScreensAndVariations()
    print(listOfScreens)

    # Load language map once per language (SpreadsheetML-aware)
    language_name = parse_language_name(language)  # '-file=English' -> 'English'
    xml_path = get_language_xml_path(language_name)
    lang_map = load_language_map(xml_path, language_name) if xml_path else {}

    for var in listOfScreens:  # loop screens/variations
        screen = var[0]
        variation = var[1]
        
        # Build third argument: -screenNum=screen;variation (ex. -screenNum=700;1)
        screen_var = '-screenNum=' + str(screen) + ';' + str(variation)
        
        # STEP 1: SIDs for this screen/variation
        sids = GetStringsForScreen_Var(screen, variation)
        print(f"SIDs for Screen {screen};{variation}:", sids)

        # STEP 2: Map SIDs → expected localized texts
        expected_texts = [lang_map[sid] for sid in sids if sid in lang_map]
        missing_in_xml = [sid for sid in sids if sid not in lang_map]
        print(f"Expected texts ({language_name}) for Screen {screen};{variation}: {expected_texts}")
        if missing_in_xml:
            print(f"Note: {len(missing_in_xml)} SID(s) not found in XML for {language_name}: {missing_in_xml}")

        # (Keeping your original run for completeness—doesn't affect Step 2)
        result = run_executable(executable_path, language, font, screen_var)
        if result and result.returncode == 0:
            print("Program executed successfully!")
        elif result:
            print(f"Program finished with exit code {result.returncode}")
        else:
            print("Failed to execute program")

def LoopThroughLanguages():
    # Exe name
    executable_path = "DesktopCP.exe"  # assuming that the exe is in the same directory as this script
    
    for language in Languages_To_Test:  # loop languages and corresponding font
        lang = language[0]
        font = language[1]

        language_arg = "-file=" + lang       # First argument
        font_arg = "-font=" + font           # Second argument
        print(language_arg)
        print(font_arg)
        
        LoopThroughScreens(executable_path, language_arg, font_arg)

def main():
    LoopThroughLanguages()

if __name__ == "__main__":
    main()
