#!/usr/bin/env python3
# Step 1 + Step 2 only (no OCR). Parses SpreadsheetML language XMLs in ./strings/

import subprocess
import sys
import os
import csv
import re
from typing import Optional, List
import xml.etree.ElementTree as ET

# ------------------------------
# Languages to test (fixed 'Croatian' spelling)
# ------------------------------
Languages_To_Test = (
    ('Croatian', 'LT'),
    ('Czech',    'LT'),
    ('Danish',   'LT'),
    ('English',  'LT'),
)

# ------------------------------
# Keep your original executable runner (unchanged)
# ------------------------------
def run_executable(exe_path, arg1, arg2, arg3):
    """
    Run an executable file with three arguments.
    (Kept from your original script. Step 2 does not depend on this.)
    """
    if not os.path.exists(exe_path):
        print(f"Error: Executable not found at {exe_path}")
        return None
    
    if not os.access(exe_path, os.X_OK):
        print(f"Warning: {exe_path} may not be executable")
    
    try:
        result = subprocess.run(
            [exe_path, arg1, arg2, arg3],
            capture_output=True,
            text=True,
            timeout=60,
            check=False
        )
        print(f"Command executed: {exe_path} {arg1} {arg2} {arg3}")
        print(f"Exit code: {result.returncode}")
        if result.stdout:
            print("Output:")
            print(result.stdout)
        if result.stderr:
            print("Errors:")
            print(result.stderr)
        return result
    except FileNotFoundError:
        print(f"Error: Could not find executable: {exe_path}")
        return None
    except Exception as e:
        print(f"Error running executable: {e}")
        return None

# ------------------------------
# CSV: screens & variations
# ------------------------------
def GetListofScreensAndVariations():
    screens = []
    with open('StringsAndVariations.csv', newline='') as f:
        reader = csv.reader(f)
        next(reader)  # skip header
        for row in reader:
            try:
                screens.append(row)
            except:
                print("Failed to Read Row in .csv")
    return screens

# ------------------------------
# STEP 1: Return SIDs only from zStringsVsScreens.txt
# ------------------------------
SID_PATTERNS = [
    re.compile(r'\bSID\s*[:=]\s*(\d+)\b', re.IGNORECASE),  # "SID=12345" / "SID: 12345"
    re.compile(r'^\s*(\d+)\b'),                            # "12345 ..."
    re.compile(r'\[(\d+)\]'),                              # "[12345]"
]

def extract_sid(line: str):
    """Return the numeric SID as a string if found in the line; otherwise None."""
    for pat in SID_PATTERNS:
        m = pat.search(line)
        if m:
            return m.group(1)
    # Fallback: first 3+ digit chunk
    m = re.search(r'\b(\d{3,})\b', line)
    return m.group(1) if m else None

def GetStringsForScreen_Var(screen, var):
    """
    Reads zStringsVsScreens.txt, finds the block for the given screen/variation,
    and returns a clean list of SIDs (strings of digits), e.g. ['12345','67890'].
    """
    foundVar = False
    sids = []

    header_prefix = "Screen = " + str(screen) + ","
    header_suffix = " Variation = " + str(var) + " uses the following SIDs:"

    with open('zStringsVsScreens.txt', 'r', encoding='utf-8') as file:
        for line in file:
            if not foundVar and (header_prefix + header_suffix) in line:
                foundVar = True
                continue

            if foundVar and line.strip() == '':
                break

            if foundVar:
                sid = extract_sid(line)
                if sid:
                    sids.append(sid)

    return sids

# ------------------------------
# STEP 2: SpreadsheetML (.xml) → { SID: text }
# ------------------------------

# Your files are Excel 2003 XML (SpreadsheetML) with this namespace:
SS_NS = "urn:schemas-microsoft-com:office:spreadsheet"
SS = f"{{{SS_NS}}}"  # for ElementTree tag names like f".//{SS}Row"

# language header synonyms (expand if needed)
LANGUAGE_SYNONYMS = {
    "english":  ["english", "en", "eng"],
    "czech":    ["czech", "čeština", "ces", "cs", "česky"],
    "danish":   ["danish", "dansk", "da"],
    "croatian": ["croatian", "hrvatski", "hr", "hrv"],
}

def parse_language_name(language_arg: str) -> str:
    """
    language_arg is like '-file=English' -> returns 'English'
    """
    try:
        return language_arg.split('=', 1)[1]
    except Exception:
        return language_arg

def get_language_xml_path(language_name: str) -> Optional[str]:
    """
    Look for XML files inside the 'strings' folder (per your project).
    """
    base_dir = os.path.join(os.getcwd(), "strings")  # assumes script runs from project root
    candidates = [
        os.path.join(base_dir, f"{language_name}.xml"),
        os.path.join(base_dir, f"{language_name}.XML"),
        os.path.join(base_dir, f"{language_name}_old.xml"),
        os.path.join(base_dir, f"{language_name}_old.XML"),
    ]
    for p in candidates:
        if os.path.exists(p):
            return p
    print(f"Warning: Could not find XML for language '{language_name}'. Tried: {candidates}")
    return None

# ---- SpreadsheetML utilities ----
def _text(elem: Optional[ET.Element]) -> str:
    return (elem.text or "").strip() if elem is not None else ""

def _row_to_cells(row: ET.Element) -> List[str]:
    """
    Convert a SpreadsheetML Row into a list of cell values (handling ss:Index gaps).
    """
    cells: List[str] = []
    col_idx = 0
    for cell in row.findall(f".//{SS}Cell"):
        # Handle ss:Index (1-based)
        idx_attr = cell.get(f"{SS}Index")
        if idx_attr and idx_attr.isdigit():
            idx = int(idx_attr) - 1
            while col_idx < idx:
                cells.append("")
                col_idx += 1
        data = cell.find(f".//{SS}Data")
        cells.append(_text(data))
        col_idx += 1
    return cells

def _read_spreadsheetml_rows(xml_path: str) -> List[List[str]]:
    """
    Read all rows (as list of strings) from the first Worksheet/Table.
    """
    tree = ET.parse(xml_path)
    root = tree.getroot()
    ws = root.find(f".//{SS}Worksheet")
    if ws is None:
        return []
    table = ws.find(f".//{SS}Table")
    if table is None:
        return []
    rows: List[List[str]] = []
    for row in table.findall(f".//{SS}Row"):
        rows.append(_row_to_cells(row))
    return rows

# ---- robust header + column detection ----
def _norm(s: str) -> str:
    return (s or "").strip().lower()

def _is_sid_header(val: str) -> bool:
    v = _norm(val)
    return v in {"sid", "id", "stringid", "sid#", "sid number", "string id"}

def _looks_like_sid_number(s: str) -> bool:
    return s.isdigit() and len(s) >= 3

def _language_candidates(lang_name: str) -> List[str]:
    base = _norm(lang_name)
    syns = LANGUAGE_SYNONYMS.get(base, [])
    return list({base, *syns})

def load_language_map(xml_path: Optional[str], language_name: str = "English") -> dict:
    """
    Parse SpreadsheetML and build { SID(number as string) : localized_text }.
    Strategy:
      1) Find a header row that contains a SID-like header and a language-like header
         (accepts synonyms like 'Hrvatski' for Croatian).
      2) If language header not found, pick the right-most non-empty header cell.
      3) If SID header not found, pick the column most often numeric in subsequent rows.
    """
    sid_to_text = {}
    if not xml_path:
        return sid_to_text

    try:
        rows = _read_spreadsheetml_rows(xml_path)
        if not rows:
            print(f"Error: No rows found in SpreadsheetML '{xml_path}'.")
            return {}

        header_idx = -1
        sid_col = -1
        lang_col = -1
        lang_cands = _language_candidates(language_name)

        # Pass 1: row with both SID-ish header and language-ish header
        for i, row in enumerate(rows):
            lowered = [_norm(c) for c in row]
            sid_cols = [j for j, v in enumerate(lowered) if _is_sid_header(v)]
            lang_cols = [j for j, v in enumerate(lowered) if v and any(v == c for c in lang_cands)]
            if sid_cols and lang_cols:
                header_idx = i
                sid_col = sid_cols[0]
                lang_col = lang_cols[0]
                break

        # Pass 2: if no language header, but SID header exists → use right-most non-empty header as language col
        if header_idx == -1:
            for i, row in enumerate(rows):
                lowered = [_norm(c) for c in row]
                sid_cols = [j for j, v in enumerate(lowered) if _is_sid_header(v)]
                if sid_cols:
                    header_idx = i
                    sid_col = sid_cols[0]
                    non_empty = [idx for idx, val in enumerate(row) if _norm(val)]
                    if non_empty:
                        lang_col = max(non_empty)
                    break

        # Pass 3: if SID col still unknown, infer by numeric-ness in next rows
        if header_idx != -1 and sid_col == -1:
            lookahead = rows[header_idx+1 : header_idx+21]
            counts = {}
            for r in lookahead:
                for j, val in enumerate(r):
                    if _looks_like_sid_number(_norm(val)):
                        counts[j] = counts.get(j, 0) + 1
            if counts:
                sid_col = max(counts, key=counts.get)

        if header_idx == -1 or sid_col == -1:
            print(f"Error: Could not locate headers in '{xml_path}'.")
            return {}

        if lang_col == -1:
            print(f"Info: Using fallback language column (right-most non-empty) in '{xml_path}'.")
            non_empty = [idx for idx, val in enumerate(rows[header_idx]) if _norm(val)]
            lang_col = max(non_empty) if non_empty else (sid_col + 1)

        # Build map
        loaded = 0
        for r in rows[header_idx+1:]:
            if sid_col >= len(r) or lang_col >= len(r):
                continue
            sid = _norm(r[sid_col])
            txt = (r[lang_col] if lang_col < len(r) else "").strip()
            if _looks_like_sid_number(sid) and txt:
                sid_to_text[sid] = txt
                loaded += 1

        print(f"Loaded {loaded} strings from '{xml_path}'. (header_row={header_idx}, sid_col={sid_col}, lang_col={lang_col})")
        return sid_to_text

    except ET.ParseError as e:
        print(f"Error: Failed to parse XML '{xml_path}': {e}")
        return {}
    except Exception as e:
        print(f"Error: Unexpected while reading SpreadsheetML '{xml_path}': {e}")
        return {}

# ------------------------------
# Main loops
# ------------------------------
def LoopThroughScreens(executable_path, language, font):
    listOfScreens = GetListofScreensAndVariations()
    print(listOfScreens)

    # Load language map once per language (SpreadsheetML-aware)
    language_name = parse_language_name(language)  # '-file=English' -> 'English'
    xml_path = get_language_xml_path(language_name)
    lang_map = load_language_map(xml_path, language_name) if xml_path else {}

    for var in listOfScreens:  # loop screens/variations
        screen = var[0]
        variation = var[1]
        
        # Build third argument: -screenNum=screen;variation (ex. -screenNum=700;1)
        screen_var = '-screenNum=' + str(screen) + ';' + str(variation)
        
        # STEP 1: SIDs for this screen/variation
        sids = GetStringsForScreen_Var(screen, variation)
        print(f"SIDs for Screen {screen};{variation}:", sids)

        # STEP 2: Map SIDs → expected localized texts
        expected_texts = [lang_map[sid] for sid in sids if sid in lang_map]
        missing_in_xml = [sid for sid in sids if sid not in lang_map]
        print(f"Expected texts ({language_name}) for Screen {screen};{variation}: {expected_texts}")
        if missing_in_xml:
            print(f"Note: {len(missing_in_xml)} SID(s) not found in XML for {language_name}: {missing_in_xml}")

        # (Optional / kept): run the EXE (not required for Step 2)
        result = run_executable(executable_path, language, font, screen_var)
        if result and result.returncode == 0:
            print("Program executed successfully!")
        elif result:
            print(f"Program finished with exit code {result.returncode}")
        else:
            print("Failed to execute program")

def LoopThroughLanguages():
    executable_path = "DesktopCP.exe"  # assuming the exe is in the same directory as this script
    
    for language in Languages_To_Test:  # loop languages and corresponding font
        lang = language[0]
        font = language[1]

        language_arg = "-file=" + lang       # First argument
        font_arg = "-font=" + font           # Second argument
        print(language_arg)
        print(font_arg)
        
        LoopThroughScreens(executable_path, language_arg, font_arg)

def main():
    LoopThroughLanguages()

if __name__ == "__main__":
    main()
