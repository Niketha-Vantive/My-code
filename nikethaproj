#!/usr/bin/env python3
# I made some progress on the script this weekend. 
# So far it will loop through a list of languages and then loop through all 
# screens/variations defined in an input file 
# (this will be the one created by you parsing the code). 
# It will then search the "zStringsVsScreens.txt" file and capture all of the strings 
# that are on the corresponding screen/var. 

# So you will still need to strip those strings out of the variable that is holding them, 
# and then use that to parse the language.xml file. 
# I can probably help with that part too if I have some time later this week. 
# Let me know if you want to walk through it at all

import subprocess
import sys
import os
import csv
import re
from typing import Optional
import xml.etree.ElementTree as ET

Languages_To_Test = (
        ('Croation', 'LT'),
        ('Czech', 'LT'),
        ('Danish', 'LT'),
        ('English', 'LT')
    )

def run_executable(exe_path, arg1, arg2, arg3):
    """
    Run an executable file with three arguments.
    """
    if not os.path.exists(exe_path):
        print(f"Error: Executable not found at {exe_path}")
        return None
    
    if not os.access(exe_path, os.X_OK):
        print(f"Warning: {exe_path} may not be executable")
    
    try:
        result = subprocess.run(
            [exe_path, arg1, arg2, arg3],
            capture_output=True,
            text=True,
            timeout=60,
            check=False
        )
        print(f"Command executed: {exe_path} {arg1} {arg2} {arg3}")
        print(f"Exit code: {result.returncode}")
        if result.stdout:
            print("Output:")
            print(result.stdout)
        if result.stderr:
            print("Errors:")
            print(result.stderr)
        return result
    except FileNotFoundError:
        print(f"Error: Could not find executable: {exe_path}")
        return None
    except Exception as e:
        print(f"Error running executable: {e}")
        return None

def GetListofScreensAndVariations():
    screens = []
    with open('StringsAndVariations.csv', newline='') as f:
        reader = csv.reader(f)
        next(reader)  # skip header
        for row in reader:
            try:
                screens.append(row)
            except:
                print("Failed to Read Row in .csv")
    return screens

# ------------------------------
# STEP 1: Return SIDs only
# ------------------------------
SID_PATTERNS = [
    re.compile(r'\bSID\s*[:=]\s*(\d+)\b', re.IGNORECASE),  # "SID=12345" / "SID: 12345"
    re.compile(r'^\s*(\d+)\b'),                            # "12345 ..."
    re.compile(r'\[(\d+)\]'),                              # "[12345]"
]

def extract_sid(line: str):
    """Return the numeric SID as a string if found in the line; otherwise None."""
    for pat in SID_PATTERNS:
        m = pat.search(line)
        if m:
            return m.group(1)
    # Fallback: first 4+ digit chunk
    m = re.search(r'\b(\d{4,})\b', line)
    return m.group(1) if m else None

def GetStringsForScreen_Var(screen, var):
    """
    Reads zStringsVsScreens.txt, finds the block for the given screen/variation,
    and returns a clean list of SIDs (strings of digits), e.g. ['12345','67890'].
    """
    foundVar = False
    sids = []

    header_prefix = "Screen = " + str(screen) + ","
    header_suffix = " Variation = " + str(var) + " uses the following SIDs:"

    with open('zStringsVsScreens.txt', 'r', encoding='utf-8') as file:
        for line in file:
            if not foundVar and (header_prefix + header_suffix) in line:
                foundVar = True
                continue

            if foundVar and line.strip() == '':
                break

            if foundVar:
                sid = extract_sid(line)
                if sid:
                    sids.append(sid)

    return sids
# ------------------------------

# ------------------------------
# STEP 2: Load language XML → { SID: text } and map SIDs to texts
# ------------------------------

def parse_language_name(language_arg: str) -> str:
    """
    language_arg is like '-file=English' -> returns 'English'
    """
    try:
        return language_arg.split('=', 1)[1]
    except Exception:
        return language_arg

def get_language_xml_path(language_name: str) -> Optional[str]:
    """
    Look for XML files inside the 'strings' folder (per your project).
    """
    base_dir = os.path.join(os.getcwd(), "strings")  # assumes script runs from project root
    candidates = [
        os.path.join(base_dir, f"{language_name}.xml"),
        os.path.join(base_dir, f"{language_name}.XML"),
        os.path.join(base_dir, f"{language_name}_old.xml"),
        os.path.join(base_dir, f"{language_name}_old.XML"),
    ]
    for p in candidates:
        if os.path.exists(p):
            return p
    print(f"Warning: Could not find XML for language '{language_name}'. Tried: {candidates}")
    return None

def load_language_map(xml_path: Optional[str]) -> dict:
    """
    Parse XML and build { SID: localized_text }.
    Tries several common schemas:
      - <String id="12345">Text</String>
      - <Item id="12345"><Text>Text</Text></Item>
      - elements with id/SID attributes, or child <SID>, and text in .text or child <Text>/<Value>/etc.
    """
    sid_to_text = {}
    if not xml_path:
        return sid_to_text

    try:
        tree = ET.parse(xml_path)
        root = tree.getroot()

        for elem in root.iter():
            # Try attributes first
            sid = elem.get('id') or elem.get('ID') or elem.get('Sid') or elem.get('SID')
            if sid and sid.isdigit():
                text = (elem.text or '').strip()
                if not text:
                    for child_tag in ('Text', 'Value', 'String', 'translation'):
                        child = elem.find(child_tag)
                        if child is not None and child.text:
                            text = child.text.strip()
                            if text:
                                break
                if text:
                    sid_to_text[sid] = text
                continue

            # If no id attribute, try a child <SID>...</SID> or similar
            sid_node = elem.find('SID') or elem.find('Id') or elem.find('ID')
            if sid_node is not None and sid_node.text and sid_node.text.strip().isdigit():
                sid = sid_node.text.strip()
                text = ''
                for child_tag in ('Text', 'Value', 'String', 'translation'):
                    child = elem.find(child_tag)
                    if child is not None and child.text:
                        text = child.text.strip()
                        if text:
                            break
                if not text and elem.text:
                    text = elem.text.strip()
                if sid and text:
                    sid_to_text[sid] = text

        print(f"Loaded {len(sid_to_text)} strings from '{xml_path}'.")
        return sid_to_text

    except ET.ParseError as e:
        print(f"Error: Failed to parse XML '{xml_path}': {e}")
        return {}
    except Exception as e:
        print(f"Error: Unexpected while reading XML '{xml_path}': {e}")
        return {}

# ------------------------------

def LoopThroughScreens(executable_path, language, font):
    listOfScreens = GetListofScreensAndVariations()
    print(listOfScreens)

    # Load language map once per language
    language_name = parse_language_name(language)  # '-file=English' -> 'English'
    xml_path = get_language_xml_path(language_name)
    lang_map = load_language_map(xml_path) if xml_path else {}

    for var in listOfScreens:  # loop screens/variations
        screen = var[0]
        variation = var[1]
        
        # Build third argument: -screenNum=screen;variation (ex. -screenNum=700;1)
        screen_var = '-screenNum=' + str(screen) + ';' + str(variation)
        
        # STEP 1: SIDs for this screen/variation
        sids = GetStringsForScreen_Var(screen, variation)
        print(f"SIDs for Screen {screen};{variation}:", sids)

        # STEP 2: Map SIDs → expected localized texts
        expected_texts = [lang_map[sid] for sid in sids if sid in lang_map]
        missing_in_xml = [sid for sid in sids if sid not in lang_map]
        print(f"Expected texts ({language_name}) for Screen {screen};{variation}: {expected_texts}")
        if missing_in_xml:
            print(f"Note: {len(missing_in_xml)} SID(s) not found in XML for {language_name}: {missing_in_xml}")

        # (Keeping your original run for completeness—doesn't affect Step 2)
        result = run_executable(executable_path, language, font, screen_var)
        if result and result.returncode == 0:
            print("Program executed successfully!")
        elif result:
            print(f"Program finished with exit code {result.returncode}")
        else:
            print("Failed to execute program")

def LoopThroughLanguages():
    # Exe name
    executable_path = "DesktopCP.exe"  # assuming that the exe is in the same directory as this script
    
    for language in Languages_To_Test:  # loop languages and corresponding font
        lang = language[0]
        font = language[1]

        language_arg = "-file=" + lang       # First argument
        font_arg = "-font=" + font           # Second argument
        print(language_arg)
        print(font_arg)
        
        LoopThroughScreens(executable_path, language_arg, font_arg)

def main():
    LoopThroughLanguages()

if __name__ == "__main__":
    main()
