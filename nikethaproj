#!/usr/bin/env python3
# I made some progress on the script this weekend. 
# So far it will loop through a list of languages and then loop through all 
# screens/variations defined in an input file 
# (this will be the one created by you parsing the code). 
# It will then search the "zStringsVsScreens.txt" file and capture all of the strings 
# that are on the corresponding screen/var. 

# So you will still need to strip those strings out of the variable that is holding them, 
# and then use that to parse the language.xml file. 
# I can probably help with that part too if I have some time later this week. 
# Let me know if you want to walk through it at all

import subprocess
import sys
import os
import csv
import re  # <-- added for SID extraction
import xml.etree.ElementTree as ET  # <-- added for XML parsing

Languages_To_Test = (
        ('Croation', 'LT'),
        ('Czech', 'LT'),
        ('Danish', 'LT'),
        ('English', 'LT')
    )

def run_executable(exe_path, arg1, arg2, arg3):
    """
    Run an executable file with three arguments.
    
    Args:
        exe_path (str): Path to the executable file
        arg1 (str): First argument
        arg2 (str): Second argument
        arg3 (str): Third argument
    
    Returns:
        subprocess.CompletedProcess: Result of the execution
    """
    
    # Check if executable exists
    if not os.path.exists(exe_path):
        print(f"Error: Executable not found at {exe_path}")
        return None
    
    # Check if file is executable (Unix-like systems)
    if not os.access(exe_path, os.X_OK):
        print(f"Warning: {exe_path} may not be executable")
    
    try:
        # Run the executable with arguments
        result = subprocess.run(
            [exe_path, arg1, arg2, arg3],
            capture_output=True,
            text=True,
            timeout=60,
            check=False  # Don't raise exception on non-zero exit code
        )
        
        ############## I think this is where we want to look if the exe opened correctly i.e. the screen/variation actually exists
        print(f"Command executed: {exe_path} {arg1} {arg2} {arg3}")
        print(f"Exit code: {result.returncode}")
        ############## Exit code 0 means it worked, not sure about failed cases
        
        # Print stdout if any
        if result.stdout:
            print("Output:")
            print(result.stdout)
        
        # Print stderr if any
        if result.stderr:
            print("Errors:")
            print(result.stderr)
        
        return result
        
    except FileNotFoundError:
        print(f"Error: Could not find executable: {exe_path}")
        return None
    except Exception as e:
        print(f"Error running executable: {e}")
        return None
        
def GetListofScreensAndVariations():
    screens = []
    with open('StringsAndVariations.csv', newline='') as f:
        reader = csv.reader(f)
        next(reader) # skip the header, could do a check to make sure file is in expected format
        for row in reader:
            try:
                screens.append(row)
            except:
                print("Failed to Read Row in .csv")
                
    return screens

# ------------------------------
# STEP 1: return SIDs only
# ------------------------------

# Patterns we try to find a SID in a line (adjust if your file uses a different format)
SID_PATTERNS = [
    re.compile(r'\bSID\s*[:=]\s*(\d+)\b', re.IGNORECASE),  # e.g., "SID=12345" or "SID: 12345"
    re.compile(r'^\s*(\d+)\b'),                            # e.g., "12345 some text"
    re.compile(r'\[(\d+)\]'),                              # e.g., "[12345]"
]

def extract_sid(line: str):
    """Return the numeric SID as a string if found in the line; otherwise None."""
    for pat in SID_PATTERNS:
        m = pat.search(line)
        if m:
            return m.group(1)
    # Fallback: grab the first 4+ digit chunk (avoids matching tiny numbers)
    m = re.search(r'\b(\d{4,})\b', line)
    return m.group(1) if m else None

def GetStringsForScreen_Var(screen, var):
    """
    Reads zStringsVsScreens.txt, finds the block for the given screen/variation,
    and returns a clean list of SIDs (strings of digits), e.g. ['12345','67890'].
    """
    foundVar = False
    sids = []

    header_prefix = "Screen = " + str(screen) + ","
    header_suffix = " Variation = " + str(var) + " uses the following SIDs:"

    with open('zStringsVsScreens.txt', 'r', encoding='utf-8') as file:
        for line in file:
            # Detect the start of the block for this screen/variation
            if not foundVar and (header_prefix + header_suffix) in line:
                foundVar = True
                continue

            # Stop when the block ends (blank line)
            if foundVar and line.strip() == '':
                break

            # While inside the block, extract SIDs
            if foundVar:
                sid = extract_sid(line)
                if sid:
                    sids.append(sid)

    return sids
# ------------------------------

# ------------------------------
# STEP 2: Load language XML â†’ { SID: text } and map SIDs to texts
# ------------------------------

def parse_language_name(language_arg: str) -> str:
    """
    language_arg is like '-file=English' -> returns 'English'
    """
    try:
        return language_arg.split('=', 1)[1]
    except Exception:
        return language_arg

def get_language_xml_path(language_name: str) -> str | None:
    """
    Try common locations/names for the language XML.
    Adjust here if your XMLs live elsewhere.
    """
    candidates = [
        f"{language_name}.xml",
        f"{language_name}.XML",
        os.path.join("Languages", f"{language_name}.xml"),
        os.path.join("Languages", f"{language_name}.XML"),
        f"language_{language_name}.xml",
        f"{language_name}_language.xml",
    ]
    for p in candidates:
        if os.path.exists(p):
            return p
    print(f"Warning: Could not find XML for language '{language_name}'. Tried: {candidates}")
    return None

def load_language_map(xml_path: str) -> dict:
    """
    Parse XML and build { SID: localized_text }.
    This is robust to a few common schemas:
      - <String id="12345">Text</String>
      - <Item id="12345"><Text>Text</Text></Item>
      - Any element with attribute id/SID and inner text or child Text/Value node.
    """
    sid_to_text = {}
    if not xml_path:
        return sid_to_text

    try:
        tree = ET.parse(xml_path)
        root = tree.getroot()

        for elem in root.iter():
            # Try attributes first
            sid = elem.get('id') or elem.get('ID') or elem.get('Sid') or elem.get('SID')
            if sid and sid.isdigit():
                # text could be in elem.text or a child like <Text>, <Value>, etc.
                text = (elem.text or '').strip()
                if not text:
                    for child_tag in ('Text', 'Value', 'String', 'translation'):
                        child = elem.find(child_tag)
                        if child is not None and child.text:
                            text = child.text.strip()
                            if text:
                                break
                if text:
                    sid_to_text[sid] = text
                continue

            # If no id attribute, try a child <SID>...</SID> or similar
            sid_node = elem.find('SID') or elem.find('Id') or elem.find('ID')
            if sid_node is not None and sid_node.text and sid_node.text.strip().isdigit():
                sid = sid_node.text.strip()
                # prefer a sibling/child holding the text
                text = ''
                for child_tag in ('Text', 'Value', 'String', 'translation'):
                    child = elem.find(child_tag)
                    if child is not None and child.text:
                        text = child.text.strip()
                        if text:
                            break
                if not text and elem.text:
                    text = elem.text.strip()
                if sid and text:
                    sid_to_text[sid] = text

        print(f"Loaded {len(sid_to_text)} strings from '{xml_path}'.")
        return sid_to_text

    except ET.ParseError as e:
        print(f"Error: Failed to parse XML '{xml_path}': {e}")
        return {}
    except Exception as e:
        print(f"Error: Unexpected while reading XML '{xml_path}': {e}")
        return {}

# ------------------------------

def LoopThroughScreens(executable_path, language, font):
    listOfScreens = GetListofScreensAndVariations()
    print(listOfScreens)

    # --- STEP 2: load the language map once per language ---
    language_name = parse_language_name(language)  # '-file=English' -> 'English'
    xml_path = get_language_xml_path(language_name)
    lang_map = load_language_map(xml_path) if xml_path else {}
    # -------------------------------------------------------

    for var in listOfScreens: # Start looping through all screens/variations
        screen = var[0]
        variation = var[1]
        
        # Start populating the cmd line string
        string = r'-screenNum=' # Create the last argument string
        string = string + str(screen) + ';' + str(variation) # make it look like -screenNum=screen;variation ex. -screenNum=700;1
        screen_var = string                # Third argument
        
        # Get the SIDs for the specific screen/variation we are looking at (STEP 1)
        sids = GetStringsForScreen_Var(screen, variation)
        print(f"SIDs for Screen {screen};{variation}:", sids)

        # --- STEP 2: Map SIDs -> expected localized texts for this language ---
        expected_texts = [lang_map[sid] for sid in sids if sid in lang_map]
        missing_in_xml = [sid for sid in sids if sid not in lang_map]
        print(f"Expected texts ({language_name}) for Screen {screen};{variation}: {expected_texts}")
        if missing_in_xml:
            print(f"Note: {len(missing_in_xml)} SID(s) not found in XML for {language_name}: {missing_in_xml}")
        # ----------------------------------------------------------------------

        # Run the executable
        # might have to figure out something slightly different here since it doesn't return until you close the window. 
        # Need to figure out how to tell if the exe successfully launched and then after we are done doing the image analysis, we must close the window and return
        result = run_executable(executable_path, language, font, screen_var)
        if result and result.returncode == 0:
            print("Program executed successfully!")
        elif result:
            print(f"Program finished with exit code {result.returncode}")
        else:
            print("Failed to execute program")
            
def LoopThroughLanguages():
    # Exe name
    executable_path = "DesktopCP.exe"  # assuming that the exe is in the same directory as this script
    
    for language in Languages_To_Test: # Start looping through all languages and their corresponding font
        lang = language[0]
        font = language[1]

        language_arg = "-file=" + lang       # First argument
        font_arg = "-font=" + font           # Second argument
        print(language_arg)
        print(font_arg)
        
        LoopThroughScreens(executable_path, language_arg, font_arg)

def main():
    LoopThroughLanguages()

if __name__ == "__main__":
    main()
