#!/usr/bin/env python3
# I made some progress on the script this weekend. 
# So far it will loop through a list of languages and then loop through all 
# screens/variations defined in an input file 
# (this will be the one created by you parsing the code). 
# It will then search the "zStringsVsScreens.txt" file and capture all of the strings 
# that are on the corresponding screen/var. 

# So you will still need to strip those strings out of the variable that is holding them, 
# and then use that to parse the language.xml file. 
# I can probably help with that part too if I have some time later this week. 
# Let me know if you want to walk through it at all

import subprocess
import sys
import os
import csv
import re  # <-- added for SID extraction

Languages_To_Test = (
        ('Croation', 'LT'),
        ('Czech', 'LT'),
        ('Danish', 'LT'),
        ('English', 'LT')
    )

def run_executable(exe_path, arg1, arg2, arg3):
    """
    Run an executable file with three arguments.
    
    Args:
        exe_path (str): Path to the executable file
        arg1 (str): First argument
        arg2 (str): Second argument
        arg3 (str): Third argument
    
    Returns:
        subprocess.CompletedProcess: Result of the execution
    """
    
    # Check if executable exists
    if not os.path.exists(exe_path):
        print(f"Error: Executable not found at {exe_path}")
        return None
    
    # Check if file is executable (Unix-like systems)
    if not os.access(exe_path, os.X_OK):
        print(f"Warning: {exe_path} may not be executable")
    
    try:
        # Run the executable with arguments
        result = subprocess.run(
            [exe_path, arg1, arg2, arg3],
            capture_output=True,
            text=True,
            timeout=60,
            check=False  # Don't raise exception on non-zero exit code
        )
        
        ############## I think this is where we want to look if the exe opened correctly i.e. the screen/variation actually exists
        print(f"Command executed: {exe_path} {arg1} {arg2} {arg3}")
        print(f"Exit code: {result.returncode}")
        ############## Exit code 0 means it worked, not sure about failed cases
        
        # Print stdout if any
        if result.stdout:
            print("Output:")
            print(result.stdout)
        
        # Print stderr if any
        if result.stderr:
            print("Errors:")
            print(result.stderr)
        
        return result
        
    except FileNotFoundError:
        print(f"Error: Could not find executable: {exe_path}")
        return None
    except Exception as e:
        print(f"Error running executable: {e}")
        return None
        
def GetListofScreensAndVariations():
    screens = []
    with open('StringsAndVariations.csv', newline='') as f:
        reader = csv.reader(f)
        next(reader) # skip the header, could do a check to make sure file is in expected format
        for row in reader:
            try:
                screens.append(row)
            except:
                print("Failed to Read Row in .csv")
                
    return screens

# ------------------------------
# STEP 1: return SIDs only
# ------------------------------

# Patterns we try to find a SID in a line (adjust if your file uses a different format)
SID_PATTERNS = [
    re.compile(r'\bSID\s*[:=]\s*(\d+)\b', re.IGNORECASE),  # e.g., "SID=12345" or "SID: 12345"
    re.compile(r'^\s*(\d+)\b'),                            # e.g., "12345 some text"
    re.compile(r'\[(\d+)\]'),                              # e.g., "[12345]"
]

def extract_sid(line: str):
    """Return the numeric SID as a string if found in the line; otherwise None."""
    for pat in SID_PATTERNS:
        m = pat.search(line)
        if m:
            return m.group(1)
    # Fallback: grab the first 4+ digit chunk (avoids matching tiny numbers)
    m = re.search(r'\b(\d{4,})\b', line)
    return m.group(1) if m else None

def GetStringsForScreen_Var(screen, var):
    """
    Reads zStringsVsScreens.txt, finds the block for the given screen/variation,
    and returns a clean list of SIDs (strings of digits), e.g. ['12345','67890'].
    """
    foundVar = False
    sids = []

    header_prefix = "Screen = " + str(screen) + ","
    header_suffix = " Variation = " + str(var) + " uses the following SIDs:"

    with open('zStringsVsScreens.txt', 'r', encoding='utf-8') as file:
        for line in file:
            # Detect the start of the block for this screen/variation
            if not foundVar and (header_prefix + header_suffix) in line:
                foundVar = True
                continue

            # Stop when the block ends (blank line)
            if foundVar and line.strip() == '':
                break

            # While inside the block, extract SIDs
            if foundVar:
                sid = extract_sid(line)
                if sid:
                    sids.append(sid)

    return sids
# ------------------------------


def LoopThroughScreens(executable_path, language, font):
    listOfScreens = GetListofScreensAndVariations()
    print(listOfScreens)
    
    for var in listOfScreens: # Start looping through all screens/variations
        screen = var[0]
        variation = var[1]
        
        # Start populating the cmd line string
        string = r'-screenNum=' # Create the last argument string
        string = string + str(screen) + ';' + str(variation) # make it look like -screenNum=screen;variation ex. -screenNum=700;1
        screen_var = string                # Third argument
        
        # Get the SIDs for the specific screen/variation we are looking at (STEP 1)
        sids = GetStringsForScreen_Var(screen, variation)
        print(f"SIDs for Screen {screen};{variation}:", sids)
        
        # Run the executable
        # might have to figure out something slightly different here since it doesn't return until you close the window. 
        # Need to figure out how to tell if the exe successfully launched and then after we are done doing the image analysis, we must close the window and return
        result = run_executable(executable_path, language, font, screen_var)
        if result and result.returncode == 0:
            print("Program executed successfully!")
        elif result:
            print(f"Program finished with exit code {result.returncode}")
        else:
            print("Failed to execute program")
            
def LoopThroughLanguages():
    # Exe name
    executable_path = "DesktopCP.exe"  # assuming that the exe is in the same directory as this script
    
    for language in Languages_To_Test: # Start looping through all languages and their corresponding font
        lang = language[0]
        font = language[1]

        language_arg = "-file=" + lang       # First argument
        font_arg = "-font=" + font           # Second argument
        print(language_arg)
        print(font_arg)
        
        LoopThroughScreens(executable_path, language_arg, font_arg)

def main():
    LoopThroughLanguages()

if __name__ == "__main__":
    main()
