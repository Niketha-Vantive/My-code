<script setup lang="ts">
import { onMounted, onUnmounted, ref, watch, nextTick } from 'vue'

const props = defineProps<{ fileParam: string }>()
const containerRef = ref<HTMLDivElement | null>(null)

let viewerInstance: any = null
let editorInstance: any = null
let docAuthSystem: any = null

let scrollerEl: HTMLElement | null = null
let mo: MutationObserver | null = null

// --------- helpers ----------
const basePath = (p?: string) => (p || '').split('?')[0]
const keyFor = (p?: string) => `nutrient-scroll:${basePath(p)}`

function getExt(url: string) {
  return url.split('?')[0].split('.').pop()?.toLowerCase() ?? ''
}

// Inner scroller & pages (PDF.js)
function findInnerScroller(root: HTMLElement): HTMLElement {
  // hard-target PDF.js first
  const pdfScroller = root.querySelector('.viewerContainer') as HTMLElement | null
  if (pdfScroller && pdfScroller.scrollHeight > pdfScroller.clientHeight) return pdfScroller

  // general fallbacks (DOCX/editor cases)
  const candidates = ['.pdfViewer', '.np-pages', '.nutrient-viewer', '.editor-scroll']
  for (const sel of candidates) {
    const el = root.querySelector(sel) as HTMLElement | null
    if (el && el.scrollHeight > el.clientHeight + 4) return el
  }

  // last resort: deepest scrollable
  let best: HTMLElement = root
  const w = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT)
  let n: any
  while ((n = w.nextNode())) {
    const el = n as HTMLElement
    if (el.scrollHeight > el.clientHeight + 4) best = el
  }
  return best
}

function getPages(scroller: HTMLElement) {
  // PDF.js pages have class "page"
  return Array.from(scroller.querySelectorAll('.page,[data-page-number],[data-page-index]')) as HTMLElement[]
}

type ScrollState = { mode: 'page'|'raw'; pageIndex?: number; offsetPct?: number; scrollTop?: number }

// Compute current page + within-page offset
function computeScrollState(root: HTMLElement): ScrollState {
  const scroller = findInnerScroller(root)
  const pages = getPages(scroller)
  if (pages.length) {
    const st = scroller.scrollTop
    let idx = 0
    for (let i = 0; i < pages.length; i++) {
      if (pages[i].offsetTop <= st + 1) idx = i; else break
    }
    const p = pages[idx]
    const h = p.offsetHeight || 1
    const delta = Math.max(0, Math.min(st - p.offsetTop, h))
    return { mode: 'page', pageIndex: idx + 1, offsetPct: delta / h }
  }
  return { mode: 'raw', scrollTop: scroller.scrollTop }
}

function applyScrollState(root: HTMLElement, state: ScrollState): boolean {
  const scroller = findInnerScroller(root)
  if (state.mode === 'page' && state.pageIndex && state.offsetPct != null) {
    const pages = getPages(scroller)
    if (pages.length && state.pageIndex - 1 < pages.length) {
      const p = pages[state.pageIndex - 1]
      const h = p.offsetHeight || 1
      scroller.scrollTo({ top: p.offsetTop + state.offsetPct * h })
      return true
    }
  }
  if (state.mode === 'raw' && typeof state.scrollTop === 'number') {
    scroller.scrollTo({ top: state.scrollTop })
    return true
  }
  return false
}

function saveScroll() {
  const root = containerRef.value; if (!root) return
  sessionStorage.setItem(keyFor(props.fileParam), JSON.stringify(computeScrollState(root)))
}

function restoreScrollWhenReady() {
  const root = containerRef.value; if (!root) return
  const raw = sessionStorage.getItem(keyFor(props.fileParam))
  if (!raw) return
  const state = JSON.parse(raw) as ScrollState
  const start = performance.now(), timeout = 7000

  const tryApply = () => {
    if (applyScrollState(root, state)) return
    if (performance.now() - start > timeout) return
    requestAnimationFrame(tryApply)
  }
  requestAnimationFrame(tryApply)
}

// Observe inner page rebuilds (happens after chatbot autofill)
function attachMutationObserver() {
  const root = containerRef.value; if (!root) return
  scrollerEl = findInnerScroller(root)

  // Save while the user scrolls (throttled)
  const throttled = (() => {
    let t: any = null
    return () => {
      if (t) return
      t = setTimeout(() => { t = null; saveScroll() }, 120)
    }
  })()
  scrollerEl.addEventListener('scroll', throttled, { passive: true })

  // Signature of current page tree
  const signature = () => {
    const pages = getPages(scrollerEl!)
    const first = pages[0]?.offsetHeight || 0
    const last  = pages[pages.length - 1]?.offsetHeight || 0
    return `${pages.length}:${first}:${last}`
  }
  let lastSig = signature()

  mo = new MutationObserver(() => {
    const s = signature()
    if (s !== lastSig) {
      lastSig = s
      // Inner DOM changed â†’ likely rebuild after autofill
      restoreScrollWhenReady()
    }
  })
  mo.observe(scrollerEl, { childList: true, subtree: true })
}

function detachMutationObserver() {
  try { scrollerEl?.replaceWith(scrollerEl!) } catch {} // noop to drop listeners if needed
  try { mo?.disconnect() } catch {}
  mo = null; scrollerEl = null
}

// --------- loader / teardown ----------
async function loadDocument(path: string) {
  const container = containerRef.value
  if (!container) return
  container.innerHTML = '' // clear old canvases/nodes

  const ext = getExt(path)

  if (ext === 'pdf') {
    const NutrientViewer = (await import('@nutrient-sdk/viewer')).default
    viewerInstance = NutrientViewer.load({
      container,
      document: path,
      baseUrl: `${location.protocol}//${location.host}/`,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true },
      toolbarOptions: { defaultTools: ['select','pen','highlight','erase','text','rectangle'] }
    })

    viewerInstance?.on?.('documentLoaded', () => {
      attachMutationObserver()
      restoreScrollWhenReady()
    })

  } else if (ext === 'docx') {
    const DocAuth = (await import('@nutrient-sdk/document-authoring')).default
    docAuthSystem = await DocAuth.createDocAuthSystem()
    const res = await fetch(path, { cache: 'no-store' })
    if (!res.ok) { console.error('Fetch failed', res.status); return }
    const blob = await res.blob()
    const doc = await docAuthSystem.importDOCX(blob)

    editorInstance = await docAuthSystem.createEditor(container, {
      document: doc,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true, structure: true },
      toolbarOptions: { defaultTools: ['select','text','highlight','rectangle','structure'] }
    })

    setTimeout(() => {
      attachMutationObserver()
      restoreScrollWhenReady()
    }, 0)
  } else {
    console.warn('Unsupported file type:', ext)
  }
}

function teardown() {
  detachMutationObserver()
  try { viewerInstance?.unload?.() || viewerInstance?.destroy?.() } catch {}
  try { editorInstance?.destroy?.() } catch {}
  viewerInstance = null
  editorInstance = null
}

// --------- wiring ----------
onMounted(async () => {
  if (props.fileParam) {
    await nextTick()
    await loadDocument(props.fileParam)
  }
})

watch(() => props.fileParam, async (newPath, oldPath) => {
  if (!newPath) return
  if (oldPath) saveScroll()
  teardown()
  await nextTick()
  await loadDocument(newPath)
})

onUnmounted(() => {
  saveScroll()
  teardown()
})
</script>
