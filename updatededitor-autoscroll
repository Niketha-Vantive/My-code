<script setup lang="ts">
import { onMounted, onUnmounted, ref, watch, nextTick } from 'vue'

const props = defineProps<{ fileParam: string }>()
const containerRef = ref<HTMLDivElement | null>(null)

let viewerInstance: any = null
let editorInstance: any = null
let docAuthSystem: any = null
let scrollerEl: HTMLElement | null = null
let mo: MutationObserver | null = null

// ---------- helpers ----------
function basePath(path?: string) { return (path || '').split('?')[0] }
function keyFor(path?: string) { return `nutrient-scroll:${basePath(path)}` }

function findInnerScroller(root: HTMLElement): HTMLElement {
  const candidates = [
    '.viewerContainer', '.pdfViewer',       // PDF.js
    '.page-view', '.pages',                 // common wrappers
    '.np-pages', '.nutrient-viewer',        // Nutrient-ish
    '.editor-scroll'
  ]
  for (const sel of candidates) {
    const el = root.querySelector(sel) as HTMLElement | null
    if (el && el.scrollHeight > el.clientHeight + 4) return el
  }
  // fallback: deepest element that scrolls
  let best: HTMLElement = root
  const w = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT)
  let n: any
  while ((n = w.nextNode())) {
    const el = n as HTMLElement
    if (el.scrollHeight > el.clientHeight + 4) best = el
  }
  return best
}

type ScrollState = { mode: 'page'|'raw'; pageIndex?: number; offsetPct?: number; scrollTop?: number }

function getPages(scroller: HTMLElement) {
  return Array.from(scroller.querySelectorAll('.page,[data-page-number],[data-page-index]')) as HTMLElement[]
}

function computeScrollState(root: HTMLElement): ScrollState {
  const scroller = findInnerScroller(root)
  const pages = getPages(scroller)
  if (pages.length) {
    const st = scroller.scrollTop
    let idx = 0
    for (let i=0;i<pages.length;i++) {
      if (pages[i].offsetTop <= st + 1) idx = i; else break
    }
    const p = pages[idx]
    const delta = Math.max(0, Math.min(st - p.offsetTop, p.offsetHeight || 1))
    return { mode:'page', pageIndex: idx+1, offsetPct: (p.offsetHeight? delta/p.offsetHeight : 0) }
  }
  return { mode:'raw', scrollTop: scroller.scrollTop }
}

function applyScrollState(root: HTMLElement, state: ScrollState): boolean {
  const scroller = findInnerScroller(root)
  if (state.mode === 'page' && state.pageIndex && state.offsetPct != null) {
    const pages = getPages(scroller)
    if (pages.length && state.pageIndex-1 < pages.length) {
      const p = pages[state.pageIndex-1]
      const tgt = p.offsetTop + state.offsetPct * (p.offsetHeight || 1)
      scroller.scrollTo({ top: tgt })
      return true
    }
  }
  if (state.mode === 'raw' && typeof state.scrollTop === 'number') {
    scroller.scrollTo({ top: state.scrollTop })
    return true
  }
  return false
}

function saveScroll() {
  const root = containerRef.value; if (!root) return
  const st = computeScrollState(root)
  sessionStorage.setItem(keyFor(props.fileParam), JSON.stringify(st))
}

function restoreScrollWhenReady() {
  const root = containerRef.value; if (!root) return
  const raw = sessionStorage.getItem(keyFor(props.fileParam))
  if (!raw) return
  const state = JSON.parse(raw) as ScrollState
  const start = performance.now(), timeout = 5000

  const tick = () => {
    if (applyScrollState(root, state)) return
    if (performance.now() - start > timeout) return
    requestAnimationFrame(tick)
  }
  requestAnimationFrame(tick)
}

// Observe inner page rebuilds and re-apply scroll
function attachMutationObserver() {
  const root = containerRef.value; if (!root) return
  scrollerEl = findInnerScroller(root)
  // save while the user scrolls
  scrollerEl.addEventListener('scroll', onScroll, { passive: true })

  let lastSig = signature()
  function signature() {
    const pages = getPages(scrollerEl!)
    // signature = page count + first/last page heights to catch reflow
    const first = pages[0]?.offsetHeight || 0
    const last  = pages[pages.length-1]?.offsetHeight || 0
    return `${pages.length}:${first}:${last}`
  }

  mo = new MutationObserver(() => {
    const s = signature()
    if (s !== lastSig) {
      lastSig = s
      // pages likely rebuilt after autofill â†’ restore
      restoreScrollWhenReady()
    }
  })
  mo.observe(scrollerEl, { childList: true, subtree: true })
}

function detachMutationObserver() {
  try { scrollerEl?.removeEventListener('scroll', onScroll) } catch {}
  try { mo?.disconnect() } catch {}
  mo = null; scrollerEl = null
}

function onScroll() {
  // throttle saving a bit
  if ((onScroll as any)._t) return
  ;(onScroll as any)._t = setTimeout(() => {
    (onScroll as any)._t = null
    saveScroll()
  }, 150)
}

// ---------- viewer/editor load ----------
function getExt(url: string){ return url.split('?')[0].split('.').pop()?.toLowerCase() ?? '' }

async function loadDocument(path: string) {
  const container = containerRef.value
  if (!container) return
  container.innerHTML = '' // clean

  const ext = getExt(path)
  if (ext === 'pdf') {
    const NutrientViewer = (await import('@nutrient-sdk/viewer')).default
    viewerInstance = NutrientViewer.load({
      container,
      document: path,
      baseUrl: `${location.protocol}//${location.host}/`,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true },
      toolbarOptions: { defaultTools: ['select','pen','highlight','erase','text','rectangle'] }
    })

    viewerInstance?.on?.('documentLoaded', () => {
      attachMutationObserver()
      restoreScrollWhenReady()
    })

  } else if (ext === 'docx') {
    const DocAuth = (await import('@nutrient-sdk/document-authoring')).default
    docAuthSystem = await DocAuth.createDocAuthSystem()
    const res = await fetch(path, { cache: 'no-store' })
    if (!res.ok) { console.error('Fetch failed', res.status); return }
    const blob = await res.blob()
    const doc = await docAuthSystem.importDOCX(blob)

    editorInstance = await docAuthSystem.createEditor(container, {
      document: doc,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true, structure: true },
      toolbarOptions: { defaultTools: ['select','text','highlight','rectangle','structure'] }
    })

    setTimeout(() => {
      attachMutationObserver()
      restoreScrollWhenReady()
    }, 0)
  } else {
    console.warn('Unsupported:', ext)
  }
}

function teardown() {
  detachMutationObserver()
  try { viewerInstance?.unload?.() || viewerInstance?.destroy?.() } catch {}
  try { editorInstance?.destroy?.() } catch {}
  viewerInstance = null; editorInstance = null
}

// ---------- wiring ----------
onMounted(async () => {
  if (props.fileParam) {
    await nextTick()
    await loadDocument(props.fileParam)
  }
})

watch(() => props.fileParam, async (newPath, oldPath) => {
  if (!newPath) return
  if (oldPath) saveScroll()
  teardown()
  await nextTick()
  await loadDocument(newPath)
})

onUnmounted(() => {
  saveScroll()
  teardown()
})
</script>
