<script setup lang="ts">
import { onMounted, onUnmounted, ref, watch, nextTick } from 'vue'

const props = defineProps<{ fileParam: string }>()

const containerRef = ref<HTMLDivElement | null>(null)
let viewerInstance: any = null
let editorInstance: any = null
let docAuthSystem: any = null

// ---------- Scroll persistence (per file) ----------
function keyFor(path?: string) {
  // persist per file; ignore cache-busting query if present
  const base = (path || '').split('?')[0]
  return `nutrient-scroll:${base}`
}
function saveScroll() {
  const el = containerRef.value
  if (!el) return
  sessionStorage.setItem(keyFor(props.fileParam), String(el.scrollTop))
}
function restoreScroll() {
  const el = containerRef.value
  if (!el) return
  const raw = sessionStorage.getItem(keyFor(props.fileParam))
  if (!raw) return
  const y = parseInt(raw, 10) || 0
  // defer until layout exists
  requestAnimationFrame(() => { el.scrollTop = y })
}
// ---------------------------------------------------

function getFileExtension(url: string): string {
  return url.split('?')[0].split('.').pop()?.toLowerCase() ?? ''
}

async function loadDocument(path: string) {
  console.log('Loading document:', path)
  const extension = getFileExtension(path)
  const container = containerRef.value
  if (!container) {
    console.error('Editor container not found!')
    return
  }

  if (extension === 'pdf') {
    const NutrientViewer = (await import('@nutrient-sdk/viewer')).default
    viewerInstance = NutrientViewer.load({
      container,
      document: path,
      baseUrl: `${window.location.protocol}//${window.location.host}/`,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true },
      toolbarOptions: { defaultTools: ['select', 'pen', 'highlight', 'erase', 'text', 'rectangle'] }
    })

    // Restore scroll when PDF pages are ready
    viewerInstance.on?.('documentLoaded', () => {
      restoreScroll()
      searchAndHighlight('Author')
    })

  } else if (extension === 'docx') {
    const DocAuth = (await import('@nutrient-sdk/document-authoring')).default
    docAuthSystem = await DocAuth.createDocAuthSystem()

    try {
      const response = await fetch(path, { cache: 'no-store' })
      if (!response.ok) {
        console.error(`Failed to fetch document: ${response.statusText}`)
        return
      }
      const docxBlob = await response.blob()
      const doc = await docAuthSystem.importDOCX(docxBlob)

      editorInstance = await docAuthSystem.createEditor(container, {
        document: doc,
        enableEditing: true,
        features: { toolbar: true, annotations: true, edit: true, structure: true },
        toolbarOptions: { defaultTools: ['select', 'text', 'highlight', 'rectangle', 'structure'] }
      })

      // Give layout a moment, then restore
      setTimeout(() => {
        restoreScroll()
        searchAndHighlight('Author')
      }, 0)

    } catch (error) {
      console.error('Error loading DOCX:', error)
    }
  } else {
    console.warn(`Unsupported file extension: .${extension}`)
  }
}

// Function to search and highlight text
function searchAndHighlight(term: string) {
  if (!term) return

  // PDF search
  if (viewerInstance?.findText) {
    viewerInstance.findText({ query: term, highlightAll: true })
    console.log(`Highlighted "${term}" in PDF`)
    return
  }

  // DOCX search
  if (editorInstance?.findText) {
    const matches = editorInstance.findText(term)
    console.log(`Found "${term}" in DOCX`, matches)
    matches.forEach((range: any) => {
      editorInstance.addHighlight(range, { color: 'yellow' })
    })
    console.log(`Highlighted "${term}" in DOCX`)
  }
}

watch(
  () => props.fileParam,
  async (newPath, oldPath) => {
    if (!newPath) return

    // Save scroll of the old doc before teardown
    if (oldPath) saveScroll()

    // Cleanup old instances
    try { viewerInstance?.unload?.(containerRef.value) } catch {}
    try { editorInstance?.destroy?.() } catch {}
    viewerInstance = null
    editorInstance = null

    await nextTick()
    console.log('Doc path received (cache-busted):', newPath)
    await loadDocument(newPath)
  }
)

onMounted(() => {
  // Make our container the scroll owner
  containerRef.value?.addEventListener('scroll', saveScroll, { passive: true })
  // If a file is already set (e.g., coming from chatbot), load it
  if (props.fileParam) {
    nextTick().then(() => loadDocument(props.fileParam))
  }
})

onUnmounted(() => {
  saveScroll()
  containerRef.value?.removeEventListener('scroll', saveScroll)
  try { viewerInstance?.unload?.(containerRef.value) } catch {}
  try { editorInstance?.destroy?.() } catch {}
})
</script>
