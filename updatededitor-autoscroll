<script setup lang="ts">
import { onMounted, onUnmounted, ref, watch, nextTick } from 'vue'

const props = defineProps<{ fileParam: string }>()

const containerRef = ref<HTMLDivElement | null>(null)

let viewerInstance: any = null
let editorInstance: any = null
let docAuthSystem: any = null

// Observers & scroller refs
let rootObserver: MutationObserver | null = null
let innerObserver: MutationObserver | null = null
let scrollerEl: HTMLElement | null = null
let scrollHandler: ((e: Event) => void) | null = null

// ===================== Scroll/DOM helpers =====================
const PAGE_SEL = '.page,[data-page-number],[data-page-index]'
const SCROLLER_SEL = '.viewerContainer' // PDF.js primary scroll container
const SCROLLER_FALLBACKS = ['.pdfViewer', '.np-pages', '.nutrient-viewer', '.editor-scroll']

const basePath = (p?: string) => (p || '').split('?')[0]
const keyFor   = (p?: string) => `nutrient-scroll:${basePath(p)}`
const getExt   = (url: string) => url.split('?')[0].split('.').pop()?.toLowerCase() ?? ''

function findInnerScroller(root: HTMLElement): HTMLElement {
  // Prefer PDF.js scroller
  const pdf = root.querySelector(SCROLLER_SEL) as HTMLElement | null
  if (pdf && pdf.scrollHeight > pdf.clientHeight) return pdf

  // Fallbacks
  for (const sel of SCROLLER_FALLBACKS) {
    const el = root.querySelector(sel) as HTMLElement | null
    if (el && el.scrollHeight > el.clientHeight + 4) return el
  }

  // Deepest scrollable element
  let best: HTMLElement = root
  const w = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT)
  let n: any
  while ((n = w.nextNode())) {
    const el = n as HTMLElement
    if (el.scrollHeight > el.clientHeight + 4) best = el
  }
  return best
}

function getPages(scroller: HTMLElement) {
  return Array.from(scroller.querySelectorAll(PAGE_SEL)) as HTMLElement[]
}

type ScrollState = { mode: 'page' | 'raw'; pageIndex?: number; offsetPct?: number; scrollTop?: number }

function computeScrollState(root: HTMLElement): ScrollState {
  const scroller = findInnerScroller(root)
  const pages = getPages(scroller)
  if (pages.length) {
    const st = scroller.scrollTop
    let idx = 0
    for (let i = 0; i < pages.length; i++) {
      if (pages[i].offsetTop <= st + 1) idx = i
      else break
    }
    const p = pages[idx]
    const h = p.offsetHeight || 1
    const delta = Math.max(0, Math.min(st - p.offsetTop, h))
    return { mode: 'page', pageIndex: idx + 1, offsetPct: delta / h }
  }
  return { mode: 'raw', scrollTop: scroller.scrollTop }
}

function applyScrollState(root: HTMLElement, state: ScrollState): boolean {
  const scroller = findInnerScroller(root)
  if (state.mode === 'page' && state.pageIndex && state.offsetPct != null) {
    const pages = getPages(scroller)
    if (pages.length && state.pageIndex - 1 < pages.length) {
      const p = pages[state.pageIndex - 1]
      const h = p.offsetHeight || 1
      scroller.scrollTo({ top: p.offsetTop + state.offsetPct * h })
      return true
    }
  }
  if (state.mode === 'raw' && typeof state.scrollTop === 'number') {
    scroller.scrollTo({ top: state.scrollTop })
    return true
  }
  return false
}

function saveScroll() {
  const root = containerRef.value
  if (!root) return
  sessionStorage.setItem(keyFor(props.fileParam), JSON.stringify(computeScrollState(root)))
}

function restoreScrollWhenReady() {
  const root = containerRef.value
  if (!root) return
  const raw = sessionStorage.getItem(keyFor(props.fileParam))
  if (!raw) return
  const state = JSON.parse(raw) as ScrollState
  const start = performance.now()
  const timeout = 7000

  const tick = () => {
    if (applyScrollState(root, state)) return
    if (performance.now() - start > timeout) return
    requestAnimationFrame(tick)
  }
  requestAnimationFrame(tick)
}

// ===================== Observers/bindings =====================
function attachInnerBindings() {
  const root = containerRef.value
  if (!root) return

  scrollerEl = findInnerScroller(root)

  // Save scroll while user scrolls (throttled)
  if (scrollHandler && scrollerEl) {
    scrollerEl.removeEventListener('scroll', scrollHandler as any)
  }
  let t: any = null
  scrollHandler = () => {
    if (t) return
    t = setTimeout(() => {
      t = null
      saveScroll()
    }, 120)
  }
  scrollerEl.addEventListener('scroll', scrollHandler, { passive: true })

  // Watch page list changes (rebuilds after autofill)
  const signature = () => {
    const pages = getPages(scrollerEl!)
    const first = pages[0]?.offsetHeight || 0
    const last = pages[pages.length - 1]?.offsetHeight || 0
    return `${pages.length}:${first}:${last}`
  }
  let lastSig = signature()

  innerObserver?.disconnect()
  innerObserver = new MutationObserver(() => {
    const s = signature()
    if (s !== lastSig) {
      lastSig = s
      restoreScrollWhenReady()
    }
  })
  innerObserver.observe(scrollerEl, { childList: true, subtree: true })
}

function attachRootObserver() {
  const root = containerRef.value
  if (!root) return
  rootObserver?.disconnect()
  rootObserver = new MutationObserver(() => {
    // If Nutrient swaps its inner viewer subtree, re-bind and restore
    attachInnerBindings()
    restoreScrollWhenReady()
  })
  rootObserver.observe(root, { childList: true, subtree: true })
}

function detachObservers() {
  try { innerObserver?.disconnect() } catch {}
  try { rootObserver?.disconnect() } catch {}
  if (scrollerEl && scrollHandler) {
    try { scrollerEl.removeEventListener('scroll', scrollHandler) } catch {}
  }
  innerObserver = null
  rootObserver = null
  scrollerEl = null
  scrollHandler = null
}

// ===================== Loaders/teardown =====================
async function loadDocument(path: string) {
  const container = containerRef.value
  if (!container) return

  // Clear old DOM to avoid stacked canvases
  container.innerHTML = ''

  const ext = getExt(path)

  if (ext === 'pdf') {
    const NutrientViewer = (await import('@nutrient-sdk/viewer')).default
    viewerInstance = NutrientViewer.load({
      container,
      document: path,
      baseUrl: `${location.protocol}//${location.host}/`,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true },
      toolbarOptions: { defaultTools: ['select', 'pen', 'highlight', 'erase', 'text', 'rectangle'] }
    })

    viewerInstance?.on?.('documentLoaded', () => {
      attachRootObserver()
      attachInnerBindings()
      restoreScrollWhenReady()
    })

  } else if (ext === 'docx') {
    const DocAuth = (await import('@nutrient-sdk/document-authoring')).default
    docAuthSystem = await DocAuth.createDocAuthSystem()

    const res = await fetch(path, { cache: 'no-store' })
    if (!res.ok) { console.error('Fetch failed', res.status, res.statusText); return }
    const blob = await res.blob()
    const doc = await docAuthSystem.importDOCX(blob)

    editorInstance = await docAuthSystem.createEditor(container, {
      document: doc,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true, structure: true },
      toolbarOptions: { defaultTools: ['select', 'text', 'highlight', 'rectangle', 'structure'] }
    })

    // After layout exists
    setTimeout(() => {
      attachRootObserver()
      attachInnerBindings()
      restoreScrollWhenReady()
    }, 0)

  } else {
    console.warn('Unsupported file type:', ext)
  }
}

function teardown() {
  detachObservers()
  try { viewerInstance?.unload?.() || viewerInstance?.destroy?.() } catch {}
  try { editorInstance?.destroy?.() } catch {}
  viewerInstance = null
  editorInstance = null
}

// ===================== Wiring =====================
onMounted(async () => {
  if (props.fileParam) {
    await nextTick()
    await loadDocument(props.fileParam)
  }
})

watch(() => props.fileParam, async (newPath, oldPath) => {
  if (!newPath) return
  if (oldPath) saveScroll()
  teardown()
  await nextTick()
  await loadDocument(newPath)
})

onUnmounted(() => {
  saveScroll()
  teardown()
})
</script>

<template>
  <div v-if="!fileParam" class="placeholder">Please select the template first.</div>
  <div v-else ref="containerRef" class="container"></div>
</template>

<style scoped>
.container {
  width: 100%;
  height: calc(100vh - 64px);
  position: relative;
  overflow: hidden; /* inner viewer owns scrolling */
}

.placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  height: calc(100vh - 64px);
  font-size: 18px;
  color: #888;
  font-style: italic;
}
</style>
