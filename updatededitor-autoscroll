<script setup lang="ts">
import { onMounted, onUnmounted, ref, watch, nextTick } from 'vue'

const props = defineProps<{ fileParam: string }>()
const containerRef = ref<HTMLDivElement | null>(null)

let viewerInstance: any = null
let editorInstance: any = null
let docAuthSystem: any = null

let scrollerEl: HTMLElement | null = null
let mo: MutationObserver | null = null
let ro: ResizeObserver | null = null
let pollTimer: number | null = null

// ---------- utils ----------
const basePath = (p?: string) => (p || '').split('?')[0]
const keyFor   = (p?: string) => `nutrient-scroll:${basePath(p)}`
const getExt   = (u: string) => u.split('?')[0].split('.').pop()?.toLowerCase() ?? ''

function findInnerScroller(root: HTMLElement): HTMLElement {
  // PDF.js typical structure
  const pdfScroller = root.querySelector('.viewerContainer') as HTMLElement | null
  if (pdfScroller && pdfScroller.scrollHeight > pdfScroller.clientHeight) return pdfScroller

  // Other likely wrappers
  const candidates = ['.pdfViewer', '.np-pages', '.nutrient-viewer', '.editor-scroll']
  for (const sel of candidates) {
    const el = root.querySelector(sel) as HTMLElement | null
    if (el && el.scrollHeight > el.clientHeight + 4) return el
  }

  // Fallback: deepest scrollable node
  let best: HTMLElement = root
  const w = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT)
  let n: any
  while ((n = w.nextNode())) {
    const el = n as HTMLElement
    if (el.scrollHeight > el.clientHeight + 4) best = el
  }
  return best
}

function getPages(scroller: HTMLElement) {
  return Array.from(scroller.querySelectorAll('.page,[data-page-number],[data-page-index]')) as HTMLElement[]
}

type ScrollState = { mode: 'page'|'raw'; pageIndex?: number; offsetPct?: number; scrollTop?: number }

function computeScrollState(root: HTMLElement): ScrollState {
  const scroller = findInnerScroller(root)
  const pages = getPages(scroller)
  if (pages.length) {
    const st = scroller.scrollTop
    let idx = 0
    for (let i = 0; i < pages.length; i++) {
      if (pages[i].offsetTop <= st + 1) idx = i; else break
    }
    const p = pages[idx]
    const h = p.offsetHeight || 1
    const delta = Math.max(0, Math.min(st - p.offsetTop, h))
    return { mode: 'page', pageIndex: idx + 1, offsetPct: delta / h }
  }
  return { mode: 'raw', scrollTop: scroller.scrollTop }
}

function applyScrollState(root: HTMLElement, state: ScrollState): boolean {
  const scroller = findInnerScroller(root)
  if (state.mode === 'page' && state.pageIndex && state.offsetPct != null) {
    const pages = getPages(scroller)
    if (pages.length && state.pageIndex - 1 < pages.length) {
      const p = pages[state.pageIndex - 1]
      const h = p.offsetHeight || 1
      scroller.scrollTo({ top: p.offsetTop + state.offsetPct * h })
      return true
    }
  }
  if (state.mode === 'raw' && typeof state.scrollTop === 'number') {
    scroller.scrollTo({ top: state.scrollTop })
    return true
  }
  return false
}

function saveScroll() {
  const root = containerRef.value; if (!root) return
  sessionStorage.setItem(keyFor(props.fileParam), JSON.stringify(computeScrollState(root)))
}

function restoreScrollWhenReady() {
  const root = containerRef.value; if (!root) return
  const raw = sessionStorage.getItem(keyFor(props.fileParam))
  if (!raw) return
  const state = JSON.parse(raw) as ScrollState

  const start = performance.now(), timeout = 8000
  const tryApply = () => {
    if (applyScrollState(root, state)) return
    if (performance.now() - start > timeout) return
    requestAnimationFrame(tryApply)
  }
  requestAnimationFrame(tryApply)
}

// ---------- observers & hooks ----------
function wireScrollSaving() {
  const root = containerRef.value; if (!root) return
  scrollerEl = findInnerScroller(root)

  // Save while the user scrolls (throttled)
  const throttled = (() => {
    let t: any = null
    return () => {
      if (t) return
      t = setTimeout(() => { t = null; saveScroll() }, 120)
    }
  })()
  scrollerEl.addEventListener('scroll', throttled, { passive: true })

  // MutationObserver (child list changes)
  mo = new MutationObserver(() => {
    // DOM changed → likely rebuild or canvases swapped
    kickRestoreCycle()
  })
  mo.observe(scrollerEl, { childList: true, subtree: true })

  // ResizeObserver (page canvas relaid out without DOM change)
  ro = new ResizeObserver(() => {
    // Layout changed → restore to previous page/offset
    kickRestoreCycle()
  })
  // observe scroller & first page (covers most PDF.js repaints)
  ro.observe(scrollerEl)
  const firstPage = getPages(scrollerEl)[0]
  if (firstPage) ro.observe(firstPage)
}

// After any detected update, attempt several times to restore
function kickRestoreCycle() {
  // Quick multi-try (covers silent repaints)
  let tries = 0
  if (pollTimer) { clearInterval(pollTimer); pollTimer = null }
  pollTimer = window.setInterval(() => {
    restoreScrollWhenReady()
    tries++
    if (tries >= 12) { // ~2s at 166ms
      if (pollTimer) { clearInterval(pollTimer); pollTimer = null }
    }
  }, 166)
}

function unwireObservers() {
  try { mo?.disconnect() } catch {}
  try { ro?.disconnect() } catch {}
  mo = null; ro = null
  if (scrollerEl) {
    // remove all listeners by cloning (safe shortcut)
    const clone = scrollerEl.cloneNode(true) as HTMLElement
    scrollerEl.replaceWith(clone)
    scrollerEl = clone
  }
}

// ---------- loading ----------
async function loadDocument(path: string) {
  const container = containerRef.value
  if (!container) return
  container.innerHTML = '' // clear previous

  const ext = getExt(path)

  if (ext === 'pdf') {
    const NutrientViewer = (await import('@nutrient-sdk/viewer')).default
    viewerInstance = NutrientViewer.load({
      container,
      document: path,
      baseUrl: `${location.protocol}//${location.host}/`,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true },
      toolbarOptions: { defaultTools: ['select','pen','highlight','erase','text','rectangle'] }
    })

    // --- PDF.js event hooks if exposed ---
    const pdfViewer = viewerInstance?.pdfViewer || viewerInstance?._pdfViewer
    const eventBus  = viewerInstance?.eventBus  || pdfViewer?.eventBus
    if (eventBus && typeof eventBus.on === 'function') {
      // fires on scroll/page change → save
      eventBus.on('updateviewarea', () => saveScroll())
      // fires when all pages are loaded → restore
      eventBus.on('pagesloaded', () => restoreScrollWhenReady())
      // fires when a page is (re)rendered → attempt restore
      eventBus.on('pagerendered', () => restoreScrollWhenReady())
    }

    viewerInstance?.on?.('documentLoaded', () => {
      wireScrollSaving()
      restoreScrollWhenReady()
    })

  } else if (ext === 'docx') {
    const DocAuth = (await import('@nutrient-sdk/document-authoring')).default
    docAuthSystem = await DocAuth.createDocAuthSystem()
    const res = await fetch(path, { cache: 'no-store' })
    if (!res.ok) { console.error('Fetch failed', res.status); return }
    const blob = await res.blob()
    const doc = await docAuthSystem.importDOCX(blob)

    editorInstance = await docAuthSystem.createEditor(container, {
      document: doc,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true, structure: true },
      toolbarOptions: { defaultTools: ['select','text','highlight','rectangle','structure'] }
    })

    setTimeout(() => {
      wireScrollSaving()
      restoreScrollWhenReady()
    }, 0)
  } else {
    console.warn('Unsupported file type:', ext)
  }
}

function teardown() {
  unwireObservers()
  try { viewerInstance?.unload?.() || viewerInstance?.destroy?.() } catch {}
  try { editorInstance?.destroy?.() } catch {}
  viewerInstance = null
  editorInstance = null
  if (pollTimer) { clearInterval(pollTimer); pollTimer = null }
}

// ---------- lifecycle ----------
onMounted(async () => {
  if (props.fileParam) {
    await nextTick()
    await loadDocument(props.fileParam)
  }
})

watch(() => props.fileParam, async (newPath, oldPath) => {
  if (!newPath) return
  if (oldPath) saveScroll()
  teardown()
  await nextTick()
  await loadDocument(newPath)
})

onUnmounted(() => {
  saveScroll()
  teardown()
})
</script>
