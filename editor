<script setup lang="ts">
import { onMounted, onUnmounted, ref, watch, nextTick } from 'vue'

const props = defineProps<{ fileParam: string }>()

const containerRef = ref<HTMLDivElement | null>(null)
const errorMsg = ref<string>('')           // show errors in UI
const loadingMsg = ref<string>('')         // show loading state

let viewerInstance: any = null
let editorInstance: any = null
let docAuthSystem: any = null

// Resolve base URL for SDK assets (works with Vite + SPA base)
const ASSETS_BASE = (import.meta as any).env?.BASE_URL || '/'

// ---------- Scroll persistence ----------
function getScrollKey(path?: string) { return `nutrient-scroll:${path ?? ''}` }
function saveScroll() {
  const el = containerRef.value; if (!el) return
  sessionStorage.setItem(getScrollKey(props.fileParam), String(el.scrollTop))
}
function restoreScroll() {
  const el = containerRef.value; if (!el) return
  const saved = sessionStorage.getItem(getScrollKey(props.fileParam))
  if (saved) requestAnimationFrame(() => { el.scrollTop = parseInt(saved, 10) || 0 })
}
// ---------------------------------------

function getFileExtension(url: string): string {
  return url.split('?')[0].split('.').pop()?.toLowerCase() ?? ''
}

function setLoading(text: string) { loadingMsg.value = text; errorMsg.value = '' }
function setError(text: string)   { errorMsg.value = text; loadingMsg.value = '' }

async function loadDocument(path: string) {
  try {
    setLoading('Loading document…')
    const extension = getFileExtension(path)
    const container = containerRef.value
    if (!container) throw new Error('Editor container not found')

    // Clear container to avoid stacking canvases
    container.innerHTML = ''

    if (extension === 'pdf') {
      const NutrientViewer = (await import('@nutrient-sdk/viewer')).default

      // NOTE: pass assets base so SDK can find its workers/wasm
      viewerInstance = NutrientViewer.load({
        container,
        document: path,
        baseUrl: ASSETS_BASE,
        assetsBaseUrl: ASSETS_BASE,
        enableEditing: true,
        features: { toolbar: true, annotations: true, edit: true },
        toolbarOptions: { defaultTools: ['select', 'pen', 'highlight', 'erase', 'text', 'rectangle'] }
      })

      viewerInstance?.on?.('documentLoaded', () => {
        setLoading('')
        restoreScroll()
        searchAndHighlight('Author')
      })

      // Fallback if event doesn’t fire
      setTimeout(() => { if (loadingMsg.value) { setLoading(''); restoreScroll(); } }, 1000)

    } else if (extension === 'docx') {
      const DocAuth = (await import('@nutrient-sdk/document-authoring')).default

      // Important: give doc-authoring its asset base too
      docAuthSystem = await DocAuth.createDocAuthSystem({ assetsBaseUrl: ASSETS_BASE })

      const response = await fetch(path, { cache: 'no-store' })
      if (!response.ok) throw new Error(`Fetch failed: ${response.status} ${response.statusText}`)
      const docxBlob = await response.blob()
      const doc = await docAuthSystem.importDOCX(docxBlob)

      editorInstance = await docAuthSystem.createEditor(container, {
        document: doc,
        enableEditing: true,
        features: { toolbar: true, annotations: true, edit: true, structure: true },
        toolbarOptions: { defaultTools: ['select', 'text', 'highlight', 'rectangle', 'structure'] }
      })

      // Give layout a tick
      setTimeout(() => {
        setLoading('')
        restoreScroll()
        searchAndHighlight('Author')
      }, 0)
    } else {
      setError(`Unsupported file type: .${extension}`)
    }
  } catch (e: any) {
    console.error('[Nutrient] loadDocument error:', e)
    setError(e?.message || 'Failed to load document')
  }
}

function teardown() {
  try { viewerInstance?.unload ? viewerInstance.unload() : viewerInstance?.destroy?.() } catch {}
  try { editorInstance?.destroy?.() } catch {}
  viewerInstance = null
  editorInstance = null
}

// Search & highlight helper
function searchAndHighlight(term: string) {
  if (!term) return
  try {
    if (viewerInstance?.findText) { viewerInstance.findText({ query: term, highlightAll: true }); return }
    if (editorInstance?.findText) {
      const matches = editorInstance.findText(term)
      matches?.forEach((range: any) => editorInstance.addHighlight(range, { color: 'yellow' }))
    }
  } catch (e) { console.warn('searchAndHighlight skipped:', e) }
}

// Initial load
onMounted(async () => {
  containerRef.value?.addEventListener('scroll', saveScroll, { passive: true })
  if (props.fileParam) {
    await nextTick()
    await loadDocument(props.fileParam)
  } else {
    setError('No file selected')
  }
})

// React to changes
watch(() => props.fileParam, async (newPath, oldPath) => {
  if (!newPath) { setError('No file selected'); return }
  if (oldPath) saveScroll()
  teardown()
  await nextTick()
  await loadDocument(newPath)
})

onUnmounted(() => {
  saveScroll()
  containerRef.value?.removeEventListener('scroll', saveScroll)
  teardown()
})
</script>
