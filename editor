<script setup lang="ts">
import { onMounted, onUnmounted, ref, watch, nextTick } from 'vue'

/**
 * Props: pass the file URL/path here (same as your current code).
 */
const props = defineProps<{ fileParam: string }>()

/**
 * Container ref that Nutrient mounts into.
 */
const containerRef = ref<HTMLDivElement | null>(null)

/**
 * Nutrient instances (PDF / DOCX).
 */
let viewerInstance: any = null
let editorInstance: any = null
let docAuthSystem: any = null

/**
 * Observers & scroller wiring.
 */
let rootObserver: MutationObserver | null = null
let innerObserver: MutationObserver | null = null
let scrollerEl: HTMLElement | null = null
let scrollHandler: ((e: Event) => void) | null = null

// ===================== Shadow-aware DOM utilities =====================
function deepWalk(root: Node, visit: (n: Node) => void) {
  const stack: Node[] = [root]
  while (stack.length) {
    const n = stack.pop()!
    visit(n)
    // traverse open shadow roots
    // @ts-ignore
    if ((n as any).shadowRoot) stack.push((n as any).shadowRoot)
    // traverse light DOM children
    // @ts-ignore
    const kids = (n as HTMLElement).children
    if (kids) for (let i = kids.length - 1; i >= 0; i--) stack.push(kids[i])
  }
}

function isScrollable(el: any): el is HTMLElement {
  if (!(el instanceof HTMLElement)) return false
  const cs = getComputedStyle(el)
  const hasY = /(auto|scroll)/.test(cs.overflowY) || /(auto|scroll)/.test(cs.overflow)
  return hasY && el.scrollHeight > el.clientHeight + 4
}

/**
 * Find the FIRST actual scrollable element under our container,
 * traversing through shadow roots as needed.
 * We prefer common viewer containers first; otherwise fallback to deepest scrollable.
 */
function deepFindFirstScrollable(rootEl: HTMLElement): HTMLElement {
  const preferred = [
    '#viewerContainer',      // PDF.js (id)
    '.viewerContainer',      // PDF.js (class)
    '.pdfViewer',
    '.np-pages',
    '.da-editor-container',  // Nutrient doc authoring
    '.nutrient-viewer',
    '.editor-scroll'
  ]

  for (const sel of preferred) {
    let found: HTMLElement | null = null
    deepWalk(rootEl, (n) => {
      if (found) return
      if (n instanceof Element) {
        const matches = (n as Element).matches?.bind(n as Element)
        if (matches && matches(sel) && isScrollable(n)) found = n as HTMLElement
      }
    })
    if (found) return found
  }

  // Fallback: pick the deepest scrollable element we can find
  let best: HTMLElement = rootEl
  deepWalk(rootEl, (n) => { if (isScrollable(n)) best = n as HTMLElement })
  return best
}

const getExt = (url: string) => url.split('?')[0].split('.').pop()?.toLowerCase() ?? ''
const basePath = (p?: string) => (p || '').split('?')[0]
const keyFor   = (p?: string) => `nutrient-scroll:${basePath(p)}`

// ===================== RAW scroll persistence (no .page nodes) =====================
type ScrollState = { scrollTop: number }

/** Read the current raw scrollTop from the true inner scroller. */
function readRawScroll(): ScrollState | null {
  const root = containerRef.value
  if (!root) return null
  const scroller = deepFindFirstScrollable(root)
  return { scrollTop: scroller.scrollTop }
}

/** Save to sessionStorage (per file). */
function saveScroll() {
  const st = readRawScroll()
  if (!st) return
  sessionStorage.setItem(keyFor(props.fileParam), JSON.stringify(st))
}

/** Restore raw scrollTop when the DOM is ready (pages laid out). */
function restoreScrollWhenReady() {
  const root = containerRef.value; if (!root) return
  const raw = sessionStorage.getItem(keyFor(props.fileParam)); if (!raw) return
  const state = JSON.parse(raw) as ScrollState

  const start = performance.now()
  const timeout = 8000

  const tryApply = () => {
    const scroller = deepFindFirstScrollable(root)
    // Only apply when content is laid out enough to scroll
    if (scroller.scrollHeight > scroller.clientHeight + 4) {
      scroller.scrollTo({ top: state.scrollTop })
      return
    }
    if (performance.now() - start > timeout) return
    requestAnimationFrame(tryApply)
  }
  requestAnimationFrame(tryApply)
}

// ===================== Observers =====================
/**
 * Bind to the current inner scroller (after each render/rebuild).
 * - Persist scroll on user scroll (throttled)
 * - Watch for page/content rebuilds and re-apply saved scrollTop
 */
function attachInnerBindings() {
  const root = containerRef.value; if (!root) return

  // Identify the current scroller
  scrollerEl = deepFindFirstScrollable(root)

  // Persist as the user scrolls (throttled)
  if (scrollHandler && scrollerEl) {
    try { scrollerEl.removeEventListener('scroll', scrollHandler as any) } catch {}
  }
  let t: any = null
  scrollHandler = () => {
    if (t) return
    t = setTimeout(() => { t = null; saveScroll() }, 120)
  }
  scrollerEl.addEventListener('scroll', scrollHandler, { passive: true })

  // Watch for inner content rebuilds (childList mutations anywhere under scroller)
  innerObserver?.disconnect()
  innerObserver = new MutationObserver(() => {
    // After autofill, Nutrient often rebuilds the inner DOM — re-apply saved scrollTop
    restoreScrollWhenReady()
  })
  innerObserver.observe(scrollerEl, { childList: true, subtree: true })
}

/**
 * Root observer: if Nutrient swaps out the entire viewer subtree,
 * re-bind to the new scroller and restore scrollTop.
 */
function attachRootObserver() {
  const root = containerRef.value; if (!root) return
  rootObserver?.disconnect()
  rootObserver = new MutationObserver(() => {
    attachInnerBindings()
    restoreScrollWhenReady()
  })
  rootObserver.observe(root, { childList: true, subtree: true })
}

function detachObservers() {
  try { innerObserver?.disconnect() } catch {}
  try { rootObserver?.disconnect() } catch {}
  if (scrollerEl && scrollHandler) {
    try { scrollerEl.removeEventListener('scroll', scrollHandler) } catch {}
  }
  innerObserver = null
  rootObserver  = null
  scrollerEl    = null
  scrollHandler = null
}

// ===================== Nutrient loaders / teardown =====================
async function loadDocument(path: string) {
  const container = containerRef.value
  if (!container) return
  container.innerHTML = '' // clear previous canvases/DOM to avoid stacking

  const ext = getExt(path)

  if (ext === 'pdf') {
    const NutrientViewer = (await import('@nutrient-sdk/viewer')).default
    viewerInstance = NutrientViewer.load({
      container,
      document: path,
      baseUrl: `${location.protocol}//${location.host}/`,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true },
      toolbarOptions: { defaultTools: ['select','pen','highlight','erase','text','rectangle'] }
    })

    viewerInstance?.on?.('documentLoaded', () => {
      // Viewer ready → bind + restore
      attachRootObserver()
      attachInnerBindings()
      restoreScrollWhenReady()
    })

  } else if (ext === 'docx') {
    const DocAuth = (await import('@nutrient-sdk/document-authoring')).default
    docAuthSystem = await DocAuth.createDocAuthSystem()

    const res = await fetch(path, { cache: 'no-store' })
    if (!res.ok) { console.error('Fetch failed', res.status, res.statusText); return }
    const blob = await res.blob()
    const doc  = await docAuthSystem.importDOCX(blob)

    editorInstance = await docAuthSystem.createEditor(container, {
      document: doc,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true, structure: true },
      toolbarOptions: { defaultTools: ['select','text','highlight','rectangle','structure'] }
    })

    // Give layout a tick, then bind + restore
    setTimeout(() => {
      attachRootObserver()
      attachInnerBindings()
      restoreScrollWhenReady()
    }, 0)

  } else {
    console.warn('Unsupported file type:', ext)
  }
}

function teardown() {
  detachObservers()
  try { viewerInstance?.unload?.() || viewerInstance?.destroy?.() } catch {}
  try { editorInstance?.destroy?.() } catch {}
  viewerInstance = null
  editorInstance = null
}

// ===================== Wire-up =====================
onMounted(async () => {
  if (props.fileParam) {
    await nextTick()
    await loadDocument(props.fileParam)
  }
})

watch(() => props.fileParam, async (newPath, oldPath) => {
  if (!newPath) return
  if (oldPath) saveScroll()
  teardown()
  await nextTick()
  await loadDocument(newPath)
})

onUnmounted(() => {
  saveScroll()
  teardown()
})
</script>

<template>
  <div v-if="!fileParam" class="placeholder">Please select the template first.</div>
  <div v-else ref="containerRef" class="container"></div>
</template>

<style scoped>
.container {
  width: 100%;
  height: calc(100vh - 64px);
  position: relative;
  /* Important: let the INNER viewer handle scrolling; we control that inner element */
  overflow: hidden;
}

.placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  height: calc(100vh - 64px);
  font-size: 18px;
  color: #888;
  font-style: italic;
}
</style>
