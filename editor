<script setup lang="ts">
import { onMounted, onUnmounted, ref, watch, nextTick } from 'vue'

const props = defineProps<{ fileParam: string }>()

const containerRef = ref<HTMLDivElement | null>(null)
let viewerInstance: any = null
let editorInstance: any = null
let docAuthSystem: any = null

// ---------- Scroll persistence ----------
function getScrollKey(path: string | undefined) {
  return `nutrient-scroll:${path ?? ''}`
}
function saveScroll() {
  const el = containerRef.value
  if (!el) return
  const key = getScrollKey(props.fileParam)
  sessionStorage.setItem(key, String(el.scrollTop))
}
function restoreScroll() {
  const el = containerRef.value
  if (!el) return
  const key = getScrollKey(props.fileParam)
  const saved = sessionStorage.getItem(key)
  if (saved) {
    requestAnimationFrame(() => {
      el.scrollTop = parseInt(saved, 10) || 0
    })
  }
}
function attachScrollListener() {
  containerRef.value?.addEventListener('scroll', saveScroll, { passive: true })
}
function detachScrollListener() {
  containerRef.value?.removeEventListener('scroll', saveScroll)
}
// ---------------------------------------

function getFileExtension(url: string): string {
  return url.split('?')[0].split('.').pop()?.toLowerCase() ?? ''
}

async function loadDocument(path: string) {
  console.log('[Nutrient] loadDocument:', path)
  const extension = getFileExtension(path)
  const container = containerRef.value
  if (!container) {
    console.error('Editor container not found!')
    return
  }

  // Clear container before re-mount just in case
  container.innerHTML = ''

  if (extension === 'pdf') {
    const NutrientViewer = (await import('@nutrient-sdk/viewer')).default
    viewerInstance = NutrientViewer.load({
      container,
      document: path,
      baseUrl: `${window.location.protocol}//${window.location.host}/`,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true },
      toolbarOptions: { defaultTools: ['select', 'pen', 'highlight', 'erase', 'text', 'rectangle'] }
    })

    // Some builds emit 'documentLoaded', others just complete the promise/mount; use both.
    viewerInstance?.on?.('documentLoaded', () => {
      console.log('[Nutrient] PDF documentLoaded')
      restoreScroll()
      searchAndHighlight('Author')
    })

    // Fallback: try restoring after a tick if no event fires
    setTimeout(() => {
      try { restoreScroll(); searchAndHighlight('Author') } catch {}
    }, 0)

  } else if (extension === 'docx') {
    const DocAuth = (await import('@nutrient-sdk/document-authoring')).default
    docAuthSystem = await DocAuth.createDocAuthSystem()

    try {
      const response = await fetch(path, { cache: 'no-store' })
      if (!response.ok) {
        console.error(`Failed to fetch document: ${response.statusText}`)
        return
      }
      const docxBlob = await response.blob()
      const doc = await docAuthSystem.importDOCX(docxBlob)

      editorInstance = await docAuthSystem.createEditor(container, {
        document: doc,
        enableEditing: true,
        features: { toolbar: true, annotations: true, edit: true, structure: true },
        toolbarOptions: { defaultTools: ['select', 'text', 'highlight', 'rectangle', 'structure'] }
      })

      // Restore once layout exists
      setTimeout(() => {
        console.log('[Nutrient] DOCX editor ready')
        restoreScroll()
        searchAndHighlight('Author')
      }, 0)

    } catch (error) {
      console.error('Error loading DOCX:', error)
    }
  } else {
    console.warn(`Unsupported file extension: .${extension}`)
  }
}

function teardown() {
  try {
    viewerInstance?.unload ? viewerInstance.unload() : viewerInstance?.destroy?.()
  } catch {}
  try {
    editorInstance?.destroy?.()
  } catch {}
  viewerInstance = null
  editorInstance = null
}

// Function to search and highlight text
function searchAndHighlight(term: string) {
  if (!term) return
  try {
    if (viewerInstance?.findText) {
      viewerInstance.findText({ query: term, highlightAll: true })
      return
    }
    if (editorInstance?.findText) {
      const matches = editorInstance.findText(term)
      matches?.forEach((range: any) => {
        editorInstance.addHighlight(range, { color: 'yellow' })
      })
    }
  } catch (e) {
    console.warn('searchAndHighlight skipped:', e)
  }
}

// Load on first mount if fileParam already has a value
onMounted(async () => {
  attachScrollListener()
  if (props.fileParam) {
    await nextTick()
    await loadDocument(props.fileParam)
  }
  // If dev hot-reload, try to restore scroll anyway
  nextTick(() => restoreScroll())
})

watch(
  () => props.fileParam,
  async (newPath, oldPath) => {
    if (!newPath) return
    if (oldPath) saveScroll()
    teardown()
    await nextTick()
    await loadDocument(newPath)
  }
)

onUnmounted(() => {
  saveScroll()
  detachScrollListener()
  teardown()
})
</script>
