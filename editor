<script setup lang="ts">
import { onMounted, onUnmounted, ref, watch, nextTick } from 'vue'

const props = defineProps<{ fileParam: string }>()

const containerRef = ref<HTMLDivElement | null>(null)
let viewerInstance: any = null
let editorInstance: any = null
let docAuthSystem: any = null

// ---------- Scroll persistence ----------
function getScrollKey(path: string | undefined) {
  return `nutrient-scroll:${path ?? ''}`
}
function saveScroll() {
  const el = containerRef.value
  if (!el) return
  const key = getScrollKey(props.fileParam)
  sessionStorage.setItem(key, String(el.scrollTop))
}
function restoreScroll() {
  const el = containerRef.value
  if (!el) return
  const key = getScrollKey(props.fileParam)
  const saved = sessionStorage.getItem(key)
  if (saved) {
    // Defer to let Nutrient lay out pages first
    requestAnimationFrame(() => {
      el.scrollTop = parseInt(saved, 10) || 0
    })
  }
}

function attachScrollListener() {
  const el = containerRef.value
  if (!el) return
  el.addEventListener('scroll', saveScroll, { passive: true })
}
function detachScrollListener() {
  const el = containerRef.value
  if (!el) return
  el.removeEventListener('scroll', saveScroll)
}
// ---------------------------------------

function getFileExtension(url: string): string {
  return url.split('?')[0].split('.').pop()?.toLowerCase() ?? ''
}

async function loadDocument(path: string) {
  const extension = getFileExtension(path)
  const container = containerRef.value
  if (!container) {
    console.error('Editor container not found!')
    return
  }

  if (extension === 'pdf') {
    const NutrientViewer = (await import('@nutrient-sdk/viewer')).default
    viewerInstance = NutrientViewer.load({
      container,
      document: path,
      baseUrl: `${window.location.protocol}//${window.location.host}/`,
      enableEditing: true,
      features: { toolbar: true, annotations: true, edit: true },
      toolbarOptions: { defaultTools: ['select', 'pen', 'highlight', 'erase', 'text', 'rectangle'] }
    })

    // When PDF pages are laid out, restore scroll then (and every reload)
    viewerInstance.on('documentLoaded', () => {
      restoreScroll()
      searchAndHighlight('Author')
    })

  } else if (extension === 'docx') {
    const DocAuth = (await import('@nutrient-sdk/document-authoring')).default
    docAuthSystem = await DocAuth.createDocAuthSystem()

    try {
      const response = await fetch(path, { cache: 'no-store' })
      if (!response.ok) {
        console.error(`Failed to fetch document: ${response.statusText}`)
        return
      }
      const docxBlob = await response.blob()
      const doc = await docAuthSystem.importDOCX(docxBlob)

      editorInstance = await docAuthSystem.createEditor(container, {
        document: doc,
        enableEditing: true,
        features: { toolbar: true, annotations: true, edit: true, structure: true },
        toolbarOptions: { defaultTools: ['select', 'text', 'highlight', 'rectangle', 'structure'] }
      })

      // Give the layout a tick, then restore scroll & search
      setTimeout(() => {
        restoreScroll()
        searchAndHighlight('Author')
      }, 0)

    } catch (error) {
      console.error('Error loading DOCX:', error)
    }
  } else {
    console.warn(`Unsupported file extension: .${extension}`)
  }
}

// Function to search and highlight text
function searchAndHighlight(term: string) {
  if (!term) return

  if (viewerInstance?.findText) {
    viewerInstance.findText({ query: term, highlightAll: true })
    return
  }

  if (editorInstance?.findText) {
    const matches = editorInstance.findText(term)
    matches.forEach((range: any) => {
      editorInstance.addHighlight(range, { color: 'yellow' })
    })
  }
}

watch(
  () => props.fileParam,
  async (newPath, oldPath) => {
    if (!newPath) return

    // Save scroll for the old doc before teardown
    if (oldPath) saveScroll()

    // Cleanup old instances
    if (viewerInstance?.unload) viewerInstance.unload(containerRef.value)
    if (editorInstance?.destroy) editorInstance.destroy()
    viewerInstance = null
    editorInstance = null

    await nextTick()
    await loadDocument(newPath)
  }
)

onMounted(() => {
  attachScrollListener()
  // If the first render already has a file, restore immediately (useful on hot reloads)
  nextTick(() => restoreScroll())
})

onUnmounted(() => {
  saveScroll()
  detachScrollListener()
  if (viewerInstance?.unload) viewerInstance.unload(containerRef.value)
  if (editorInstance?.destroy) editorInstance.destroy()
})
</script>

<style scoped>
.container {
  width: 100%;
  height: calc(100vh - 64px);
  position: relative;
  overflow: auto; /* make this the scroll owner we control */
}

.placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  height: calc(100vh - 64px);
  font-size: 18px;
  color: #888;
  font-style: italic;
}
</style>
